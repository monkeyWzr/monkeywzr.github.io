---
title: Js tips I can't remember
tags:
    - JavaScript
category: 技术
keywords:
    - Javascript
    - ES2015
    - ES6
---

## `__proto__` VS `prototype`

>`__proto__` is the actual object that is used in the lookup chain to resolve methods and others. `prototype` is the object that is used to build `__proto__` when creating an object with `new`.
[https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript](https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript)

```javascript
( new Foo ).__proto__ === Foo.prototype; // true
( new Foo ).prototype === undefined; // true
```
<!--more-->

## `{}` VS `Object.create(null)`

`Object.create(null)` can create a *'pure'* empty object that is without the delegation to `Object.prototype`.
```javascript
let obj1 = {};
let obj2 = Object.create(null);
console.log(obj1.__proto__); // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
console.log(obj2.__proto__); // undefined
```

## Computed Property Names

ES6 adds computed property names, which is helpful when declaring objects using the object-literal syntax.
```javascript
var prefix = "foo";

var myObject = {
	[prefix + "bar"]: "hello",
	[prefix + "baz"]: "world"
};

myObject["foobar"]; // hello
myObject["foobaz"]; // world
```

## Dangerous `Function.prototype.name` comparison

Sometimes we may spectify a function by comparing the function name:
```javascript
function Foo() {};
let foo = new Foo();

if (foo.constructor.name === 'Foo') {
  console.log("'foo' is an instance of 'Foo'");
} else {
  console.log('Oops!');
}
```

It may behave unexpectedly after building because most build tools compress the code to forms like:
```javascript
function a() {};
let b = new a();
if (b.constructor.name === 'Foo') {
  console.log("'foo' is an instance of 'Foo'");
} else {
  console.log('Oops!');
}
```

## A more robust way of performing object property check

Normally we use `hasOwnProperty()` checks to see if object has the property or not. But consider objects created by:
```javascript
// this will not consult the [[Prototype]] chain
let obj = Object.create(null)
```
Such object does not link to `Object.prototype`, thus `obj.hasOwnProperty(...)` would fail and raise error.

We can use a more robust way to perform property check:
```javascript
Object.prototype.hasOwnProperty.call(obj,"a") //false
```
Or:
```javascript
// this will check the current object or any higher level of the [[Prototype]] chain
"a" in obj
```
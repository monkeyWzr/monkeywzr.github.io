---
title: ioc要点简记
date: 2016-08-24 01:50:45
categories: notes
tags:
    - php
    - laravel
keywords:
    - IOC
    - laravel
    - php
    - 软件工程
    - 设计模式
---

>文中资料出处：
>[浅谈IOC--说清楚IOC是什么](http://www.cnblogs.com/DebugLZQ/archive/2013/06/05/3107957.html)
>[浅谈 Laravel 设计模式](https://phphub.org/topics/1954)
>[深度理解依赖注入](http://www.cnblogs.com/xingyukun/archive/2007/10/20/931331.html)

## IOC的含义

>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。

面向对象设计及编程的基本思想简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。

<!-- more -->

在面向对象设计的软件系统中，它的底层都是由N个对象构成的，各个对象之间通过相互合作，最终实现系统地业务逻辑。
![img](/img/2016-8-31-ioc-notes_1.png)
伴随着应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。

IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。
![img](/img/2016-8-31-ioc-notes_2.png)
由图可以看出，系统增加了在中间位置的第三方。此时构成系统的各个部分并没有耦合关系，而是是借助这个第三方来互相粘合。这个第三方也就是IOC容器的作用。在容器的穿针引线下，系统的各个部分才能结合起来发挥作用。如果图中没有IOC容器这个第三方存在，系统的各个部件彼此毫无联系。也就是说，在实现与变更A的时候，完全不用考虑与其他部件之间的影响。
这也就是IOC（控制反转）这个名字的含义： 软件系统在没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。
软件系统在引入IOC容器之后，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。

    //主动依赖
    function __construct() {
            $this->user = new UserModel();
    }

    //被动依赖
    function __construct(UserModel $user) {
            $this->user = $user;
    }

IOC中最基本的技术就是 __反射(Reflection)__ 编程。反射通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。很多框架中都是把“反射”做为最基本的技术手段。

## IOC的优缺点

### 优点

* flexibility
    - changing the implementation class for a widely used interface is simpler (e.g. replace a mock web service by the production instance)
    - changing the retrieval strategy for a given class is simpler (e.g. moving a service from the classpath to the JNDI tree)
    - adding interceptors is easy and done in a single place (e.g. adding a caching interceptor to a JDBC-based DAO)
* readability
    -the project has one unified and consistent component model and is not littered with factories (e.g. DAO factories)
    -the code is briefer and is not littered without dependency lookup code (e.g. calls to JNDI InitialContext)
* testability
    - dependencies are easy to replace mocks when they're exposed through a constructor or setter
    - easier testing leads to more testing
    - more testing leads to better code quality, lower coupling, higher cohesion

我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTkxNzA1MjU5MCwtMzE5NTUzMDldfQ==
-->
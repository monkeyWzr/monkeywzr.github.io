<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>マクロス</title><link>https://www.takuzen.me/</link><description>Recent content on マクロス</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>呉</copyright><lastBuildDate>Mon, 22 Mar 2021 16:31:57 +0900</lastBuildDate><atom:link href="https://www.takuzen.me/index.xml" rel="self" type="application/rss+xml"/><item><title>プログラミングTypeScriptの読書メモ - 型</title><link>https://www.takuzen.me/posts/programming-typescript-notes-types/</link><pubDate>Mon, 22 Mar 2021 16:31:57 +0900</pubDate><guid>https://www.takuzen.me/posts/programming-typescript-notes-types/</guid><description>難しすぎて、一回3−4ページ文しか進められてない、、
よく自分に聞く：Is this something about TYPEScript(exists only during compile time) or not(to be dealt at runtime)?
聞きながら勉強すると大変助かります。
高度な型 サブタイプとスーパータイプ anyはすべての型のスーパータイプ neverはすべての型のサブタイプ 変性 不変性(invariance) 共変性(covariance) 反変性(contravariance) 双変性(bivariance) ディフォルトでTypescriptの型に関して共変です。 {&amp;quot;strictFunctionTypes&amp;quot;: true}の場合、関数型にはそのパラメータの型が反変にと扱うようにする。具体は下記を参照ください。
関数型の関係と反変 class Animal {} class Bird extends Animal { chirp() {} } class Crow extends Bird { caw() {} } function clone (f: (b:Bird) =&amp;gt; Bird): void { } clone関数は、関数型のパラメータを期待する。(b: Bird) =&amp;gt; Bird型の関数、とそのサブタイプの関数を渡すことができる。 ここまでは普通の共変であり、反変に関係ない。
ではどんな関数は(b: Bird) =&amp;gt; Birdのサブタイプでしょうか</description></item><item><title>JavaのArrays.asListのシグネチャーを始めとしてVarargsとバイトコードを調査した件</title><link>https://www.takuzen.me/posts/java-varargs-and-primitive-types/</link><pubDate>Fri, 29 Jan 2021 23:39:16 +0900</pubDate><guid>https://www.takuzen.me/posts/java-varargs-and-primitive-types/</guid><description>0. 課題 数日前、配列を出力したいので下記のようなコードを書いた
public class Nani { public static void main(String[] args) { int[] nums = new int[]{1, 2, 3, 4}; Arrays.asList(nums).forEach(i -&amp;gt; System.out.println(i + &amp;#34; &amp;#34;)); } } Ideaコード補完の提示に従って書いたし、エラーもないけど実行すると1 2 3 4ではなく、 [I@5ba23b66というようなやつが出力された。オブジェクトとして出力されてることが分かてるけどこれ以上理解できなかった。
友達からヒントをもらって、Integerにすると
Integer[] nums2 = new Integer[]{1, 2, 3, 4}; Arrays.asList(nums2).forEach(i -&amp;gt; System.out.print(i + &amp;#34; &amp;#34;)); 1 2 3 4になった。Listとかジェネリクスとかプリミティブとかに関係あるだろうと思って色々調べてみた。
結局、これらJavaの基本コンセプト:
Varargs Autoboxing Generics はいずれもよく把握してなかった。
ちなみに、Arrays#toStringで簡単に配列が出力できる1
System.out.println(Arrays.toString(array)); // [1, 2, 3, 4] 1. 基本知識の明確 1.1 ジェネリクス「T」にはプリミティブ型が含まれていない.</description></item><item><title>思考せずに毎日gettersとsettersを実装している私、その理由が分からない</title><link>https://www.takuzen.me/posts/pretend-to-understand-getters-and-setting/</link><pubDate>Sun, 17 Jan 2021 18:05:32 +0900</pubDate><guid>https://www.takuzen.me/posts/pretend-to-understand-getters-and-setting/</guid><description>最近lombokを使って下記のようなやつを結構実装していた
@Getter @Setter // @Dataもよく使ってる public class Foo { private String name; private int id; } ある日、考えずに動いてる俺は突然目覚めた：上記のような処理せずフィールドの値の参照と設定だけの場合、fieldのアクセス修飾子をpublicにして直接使ったらいいんじゃない？lombokを使ってgettersとsettersを生成する目的は何だっけ？gettersとsettersは何だっけ？
いつからgetters/settersを使うことを習慣になるのか、どこから学んだのか全然覚えてないので、調査してみた。
TL;DR 関係あるキーワード:
Encapsulation, Accessors, Immutable, JavaBeans, POJO, Persistence Ignorance, YAGNI, ORM
Java世界にgetters/setters手法の定番化は、Beanの概念の誕生、発展、およびJavaエコシステムの発展に関係があります。
POJOはライブラリに依存せずごく普通なオブジェクトである、JavaBeanは再利用可能なGUIコンポーネントの定義として登場、現在にいたってBeanの名前で再利用コンポーネントの概念として使われている
調査した後、先頭のような場合なら、publicデータフィルドで扱う方が良いかもしれないじゃないかと思っているが断言できません。 常に考えて、適切な処理を実装するのは大切だと思う。
まず、getters/settersをおすすめしている資料を探した getters/settersはJavaオブジェクト指向プログラミングの入門教材の定番としてよく見られ、カプセルかとかの概念に紐付けられているような印象がある。 だがgoogleしてみるとgetters/settersの必要性を疑ているタイトルがいっぱい出てきた。
おすすめしている資料の一例： Why Should I Write Getters and Setters
後半から
I understand, but generally, we do not write anything in getters/setters. We just return and set the field, which is same as exposing a field as public.</description></item><item><title>Springでjsonリクエスト情報のカスタマイズ処理（変換、バリデーション、共通処理）</title><link>https://www.takuzen.me/posts/spring-handle-request-arguments/</link><pubDate>Mon, 04 Jan 2021 15:13:31 +0900</pubDate><guid>https://www.takuzen.me/posts/spring-handle-request-arguments/</guid><description>内容要補足
共通処理 HandlerInterceptor ControllerAdvice/RestControllerAdvice RequestBodyAdvice @RequestBodyの共通処理に適用。 Filter 不勉強すみません AOP 不勉強againすみません カスタマイズ変換の視点から、下記の方法がある（特に@RequestParamから取得したStringからオブジェクトへのカスタマイズ変換）
RequestBodyAdvice @RequestBodyに適用 ConverterFactory ArgumentResolver @RequestParamとかの制御に適用（カスタマイズ変換） PropertyEditor @RequestParamとかの制御に適用（カスタマイズ変換） HandlerInterceptor インターフェース HandlerInterceptor
リクエストがハンドルされる前後にインタセプトするインタフェースです。（Controllerは当然handlerであると認識しているが、なぜこのインタフェースの名前がControllerIntercepterになってないでしょうか）
インタフェースによりインタセプトタイミングを見ると、Restアプリケーションの場合（特に共通バリデーションとかをしたい場合）に役割が少ないと思った1
preHandle: ハンドラー(controller)メソッドが呼び出される前に呼び出される。httpRequestとhttpResponseがパラメータであるので、一部の前処理とかを実装できる postHandle: ハンドラーメソッドが呼び出された後、DispatcherServlet がビューをレンダリングする前に呼び出される afterCompletion:　ビューのレンダリング後のコールバック 最近のプロジェクトに、preHandleでログ出力の初期設定を行う、afterCompletionでMDCのクリアを行う、のような仕組みを応用した。
ControllerAdvice/RestControllerAdvice Controllerクラスの間に、@ExceptionHandler @InitBinder @ModelAttributeの処理を共通定義できる
Data Binder, Model, Exceptionの共通カスタマイズ処理とかに適用
@ControllerAdvice // @RestControllerAdvice // RestControllerの場合 class SomeCustomControllerAdvice { @InitBinder public void initDataBinder(WebDataBinder dataBinder) { // dataBinder.registerCustomEditorでカスタマイズエディターの登録を行ったり // dataBinder.getTarget()でハンドラーメソッドに渡すPOJOオブジェクトのインスタンスも取得できる } @ModelAttribute public void addSomething(@RequestParam(&amp;#34;someKey&amp;#34;) String someValue, Model model) { // モデルを更新するとか // ハンドラーのようにリクエストパラメータを取得できるので、前処理とか実装できる } @ExceptionHandler // @ExceptionHandler({NullPointerException.</description></item><item><title>プログラミングTypeScriptの読書メモ</title><link>https://www.takuzen.me/posts/programming-typescript-notes/</link><pubDate>Fri, 01 Jan 2021 17:01:34 +0900</pubDate><guid>https://www.takuzen.me/posts/programming-typescript-notes/</guid><description>リテラル let a = 1 // number let c : 3 = 3; // リテラル型 3 const b = 2 // リテラル型 2 const d: number = 4 // number 構造的型付け(structural typing) ダックタイピング
→名前的型付け
インデックスシグネチャ { [key: T]: U } オブジェクトについて 空のオブジェクトリテラル表記{}とオブジェクトプロトタイプ表記Objectはできるだけ避けてください。
let foo: {} foo = 1; foo = {a: 1}; foo = []; foo = &amp;#39;abc&amp;#39;; let bar : Object; bar = 1; bar = {a: 1} bar = [] bar = &amp;#39;abc&amp;#39; foo = {toString() {return 1}} // OK bar = {toString() {return 1}} // Error: Type ‘() =&amp;gt; number’ is not assignable to type ‘() =&amp;gt; string’.</description></item><item><title>Jestでaxiosはネットワークエラーになってしまう件</title><link>https://www.takuzen.me/posts/jest-axios-network-error/</link><pubDate>Wed, 30 Dec 2020 18:02:38 +0900</pubDate><guid>https://www.takuzen.me/posts/jest-axios-network-error/</guid><description>JestでAPIを検証しようとした時、axiosからネットワークエラーが発生した。 背景：localhost:9090のwebpack-server経由でlocalhost:8080のバックサービスを叩く
色々調べると、ランタイム環境に関係ありそう。ちゃんとわかってないけど
解決案１ axiosアダプタをnode環境用のhttpアダプタを使うように変更する1。今回これを使って解決した
import axios from &amp;#39;axios&amp;#39; import httpAdapter from &amp;#39;axios/lib/adapters/http&amp;#39; const instance = axios.create({ adapter: httpAdapter, // ... }); 解決案２ jestのディフォルト環境はブラウザ風のjsdomなので、nodeに変更すればできるはず2
// jest.config.js module.exports = { testEnvironment: &amp;#34;node&amp;#34; }; 又はjest --env=nodeで実行する3
参考 Jestは、axiosで認証されたリクエストを行うと「ネットワークエラー」を返します
configuration#testenvironment-string
Jestでaxiosを使おうとするとNetwork Errorになってうまくいかないときの対処方法
https://stackoverflow.com/a/42678578&amp;#160;&amp;#x21a9;&amp;#xfe0e;
https://www.tolog.site/aws/jest-sam-network-error/&amp;#160;&amp;#x21a9;&amp;#xfe0e;
https://github.com/axios/axios/issues/938&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>WebpackのDefinePluginで環境変数を定義する</title><link>https://www.takuzen.me/posts/webpack-defineplugin/</link><pubDate>Wed, 30 Dec 2020 16:42:34 +0900</pubDate><guid>https://www.takuzen.me/posts/webpack-defineplugin/</guid><description>webpackのDefinePluginでグローバル環境変数が定義できる。
new webpack.DefinePlugin({ // Definitions... }); コンパイル時直接テキスト置換でインラインかされるので、文字列の値を定義したい場合、実際のクォーテーションを含める必要がある1
Note that because the plugin does a direct text replacement, the value given to it must include actual quotes inside of the string itself. Typically, this is done either with alternate quotes, such as &amp;lsquo;&amp;ldquo;production&amp;rdquo;&amp;rsquo;, or by using JSON.stringify(&amp;lsquo;production&amp;rsquo;).
new webpack.DefinePlugin({ PRODUCTION: JSON.stringify(true), // true BROWSER_SUPPORTS_HTML5: true, // true VERSION: JSON.stringify(&amp;#39;5fa3b9&amp;#39;), // &amp;#39;5fa3b9&amp;#39; &amp;#39;SERVICE_URL&amp;#39;: &amp;#39;https://dev.example.com&amp;#39;, // highly possible to recieve a compile error &amp;#39;typeof window&amp;#39;: &amp;#39;&amp;#34;object&amp;#34;&amp;#39;, TWO: &amp;#39;1+1&amp;#39;, // 2 &amp;#39;process.</description></item><item><title>依存性逆転の原則(Dependency Inversion Principle), the D in SOLID</title><link>https://www.takuzen.me/posts/dependency-inversion-principle/</link><pubDate>Sat, 19 Dec 2020 15:43:21 +0900</pubDate><guid>https://www.takuzen.me/posts/dependency-inversion-principle/</guid><description>SOLIDの一つである、依存性逆転の原則(Dependency Inversion Principle, DIP)は一体どういうものか？色々調査してみた。今までもはっきりわかったと言えないがある程度納得したと思う。
まず、依存性の注入(DI)は依存性逆転の原則(DIP)ではない よく言われてる依存性の注入(Dependency Injection, DI)と依存性逆転の原則は、全く別のものである。
あるクラスBの中には、別のクラスAを使う場合、BはAを依存している
class A { public A(int p) { // ... } } class B { public B() { A a = new A(1); // ... } public static void main(String[] args) { B b = new B(); } } DIていうのは、その依存対象を直接扱う代わりに、外から注入することです。
class B { public B(A a) { // ... } public static void main(String[] args) { A a = new A(1); B b = new B(a);　// Bの依存を注入する } } SpringとかのフレームワークはDIを利用して依存関係を管理して注入してくれる。</description></item><item><title>Spring Bean Scope: Singleton and Prototype</title><link>https://www.takuzen.me/posts/spring-bean-scope/</link><pubDate>Sun, 13 Dec 2020 16:36:42 +0900</pubDate><guid>https://www.takuzen.me/posts/spring-bean-scope/</guid><description>シングルトンsingleton Only one instance is created and managed in the Spring container. This instance is shared by all requests so we should use this for stateless beans. Singleton scope is the default scope in Spring.
@Service public class SomeService{ // DANGER! This property is shared by all requests so one user might use others&amp;#39; password private String password; public void authByPassword(){ // ... } } prototype A new instance is created by each request for that bean.</description></item><item><title>N1を目指す</title><link>https://www.takuzen.me/posts/2020-10-15-japanese-notes/</link><pubDate>Thu, 15 Oct 2020 15:43:21 +0900</pubDate><guid>https://www.takuzen.me/posts/2020-10-15-japanese-notes/</guid><description>[]いわば []おまけに []すなわち [x]あるいは []さりとて：＝だが []さりとは： [x]したがって：従って []せざるを得ない：＝しないわけにはいかない、＝しなければならない []にもかかわらず []もしくは：（若しくは）＝あるいは []それゆえ：（それ故）それだから（ちょっと正式の表現） [x]そもそも：抑々 []むしろ：寧ろ。どちらかと言えば
やんわりと 活字離れ（かつじばなれ） 時間を割く「に時間を食われる」 飛ばし読み 偏る 到底（とうてい） じっくり まいった　＝　やられている　打ちのめされてる まだまし おめでたい　＝　皮肉
あいにく持ち合わせなくて
一緒にさせていただいても差し支えありませんか
お中元
からする なればなったで（～ば～で）
ことはない　意地悪な/ひどいことをするような状況じゃない どころではない　～をする時間がない/～をする状況にない わけはない　蛙が空を飛ぶわけはない までではない　ほどのことではない　～という程度までには達してない ほどには当たらない　存在しない文型 までのことではない までにはあたらない
見るともなしに
忍びず　～がもったいなくて はばからず　べくして</description></item><item><title>Changes to String in java (from 1.7.0_06)</title><link>https://www.takuzen.me/posts/2020-06-06-changes-in-java-string/</link><pubDate>Sat, 06 Jun 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-06-06-changes-in-java-string/</guid><description>Before 1.7.0_06, String has 4 non static field:
char[] value int[] offset int count int hash Subing.substring create a String by sharing the original String&amp;rsquo;s internal char[] value and setting offset. This saves memory and makes String.substring run in a constant time($O(1)$). Meanwhile, this feature may cause memory leak1.
http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/8deef18bb749/src/share/classes/java/lang/String.java
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence { /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used.</description></item><item><title>Algorithms - String Sorts</title><link>https://www.takuzen.me/posts/2020-06-05-string-sorts/</link><pubDate>Fri, 05 Jun 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-06-05-string-sorts/</guid><description>Key-indexed counting Sort an array a[] of N integers between 0 and R-1.
int N = a.length; // the temp array during sorting int[] aux = new int[N]; // the index of count[] is the integer int[] count = new int[R+1]; // count frequencies of N integers // offset by one(a[0] = 0) for (int i = 0; i &amp;lt; N; i++) { count[a[i]+1]++; } // compute frequency cumulates which specify destinations // (how many intgers &amp;lt; the integer r) for (int r = 0; r &amp;lt; R; R++) { count[r+1] += count[r]; } // access cumulates using key as index to move items for (int i = 0; i &amp;lt; N; i++) { aux[count[a[i]]++] = a[i]; } // copy back for (int i = 0; i &amp;lt; N; i++) { a[i] = aux[i]; } Key-indexed counting is stable.</description></item><item><title>Algorithms - Maxflow and Mincut</title><link>https://www.takuzen.me/posts/2020-05-20-maxflow-mincut/</link><pubDate>Wed, 20 May 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-05-20-maxflow-mincut/</guid><description>Model We use a flow network model which is an edge-weighted digraph with positive edge weights referred to as capacities. An st-flow network has two identified vertices, a source s and a sink t.
Minimum Cut problem An st-cut is a partition of the vertices into two disjoint sets, which s in one set A and t in the other set B. Its capacity is the sum of the capacities of the edges from A to B.</description></item><item><title>Algorithms - Graphs</title><link>https://www.takuzen.me/posts/2020-05-01-algorithms-graphs/</link><pubDate>Fri, 01 May 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-05-01-algorithms-graphs/</guid><description>Undirected Graphs Some problems Path Shortest path Cycle Ehler tour: A cycle that uses each edge excatly once. Hamilton tour: A cycle that uses each vertex exactly once classical NP-complete problem. Connectivity MST: Biconnectivity: A vertex whose removal disconnects the graph Planarity Graph isomorphism: Are two graphs identical? No one knows so far. A lonstanding open problem Representations Real-world graphs tend to be sparse (huge number of vertices, small average vertex degree).</description></item><item><title>Programming Language - Subtyping</title><link>https://www.takuzen.me/posts/2020-04-29-subtyping/</link><pubDate>Wed, 29 Apr 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-04-29-subtyping/</guid><description>Some Good Subtyping Rules Width subtyping: A supertype can have a subset of fields with the same types, i.e., a subtype can have extra fields. Permutation subtypings: A supertype can have the same set of fields with the same types in a different order. Transitivity: if t1 is subtype of t2, and t2 is subtype of t3, then t1 is subtype of t3. Reflexivity: Every type is a subtype of itself.</description></item><item><title>Racket notes</title><link>https://www.takuzen.me/posts/2020-02-29-racket/</link><pubDate>Sat, 29 Feb 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-02-29-racket/</guid><description>Basic #lang racket (provide (all-defined-out)) ;this is a comment (define s &amp;#34;hello&amp;#34;) (define x 3) (define y (+ x 2)) (define cube1 (lambda (x) (* x (* x x)))) (define cube2 (lambda (x) (* x x x))) (define (cube3 x) (* x x x)) (define (pow1 x y) (if (=y 0) 1 (* x (pow1 x (- y 1))))) ; currying (define pow2 (lambda (x) (lambda (y) (pow1 x y)))) List Empty list: null () doesn&amp;quot;t work for null but '() does build a list: (list e1 .</description></item><item><title>Standard ML notes</title><link>https://www.takuzen.me/posts/2019-12-30-standardml-notes/</link><pubDate>Tue, 10 Dec 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-12-30-standardml-notes/</guid><description>Basics Comments (* SML comment *) Variable bindings and Expressions val x = 34; (* static environment: x : int *) (* dynamic environment: x --&amp;gt; 34 *) val y = x + 1; (* Use tilde character instead of minus to reprsent negation *) val z = ~1; (* Integer Division *) val w = y div x Strings:
(* `\n`のようなエスケープシーケンスが利用できる *) val x = &amp;quot;hello\n&amp;quot;; (* 文字列の連結には'^'を使う *) val y = &amp;quot;hello &amp;quot; ^ &amp;quot;world&amp;quot;; An ML program is a sequence of bindings.</description></item><item><title>uipath ノート（三）- uipath orchestrator</title><link>https://www.takuzen.me/posts/2019-11-23-uipath-orchestrator/</link><pubDate>Sat, 23 Nov 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-11-23-uipath-orchestrator/</guid><description>利用手順 Official doc: https://docs.uipath.com/robot/docs/from-orchestrator-and-the-orchestrator-settings-window
マシンを追加 マシン側でマシン名とユーザ名を確認
C:\Users\user&amp;gt;hostname DESKTOP-ABCDE5F C:\Users\user&amp;gt;whoami desktop-abcde5f\user C:\Users\user&amp;gt; 追加完了後、マシンキーを取得する。
ロボットを登録 Type: studio (開発用？) Domain/Username: 上記のユーザ名 ローカルのorchestrator設定 Uipath Robotを開き⇒orchestratorの設定で、上記のマシンキーを入力する。 orchestrator URLに https://platform.uipath.com/ を入力する. Invalid machine keyというエラーが出たら、下記のようなURLを試す：
https://platform.uipath.com/&amp;lt;account name&amp;gt;/&amp;lt;service name&amp;gt; 参照：Uipath orchestrator error : invalid machine key
ロボットグループ(Environment)作成 プロジェクトをパブリッシュ(Publish) プロセスを追加 Automations　⇒　Processes
ジョブ(Jobs)の実行 Monitoring　⇒　Jobs
その他 再パブリッシュすると、Processが最新バージョンを使うため、変更作業が必要 Processes　⇒　More Options　⇒　View Process　⇒　最新のバージョンに切り替える
ジョブの停止 停止(Stop)：必ずワークフロー内で「停止すべきか確認(Should Stop)」アクティビティを使用する 強制終了(Kill)：処理中の内容に関わらず、ジョブを停止する アクティブなジョブは削除できない パラメーター変更の優先順位 ジョブ (Jobs) -&amp;gt; プロセス (Processes) -&amp;gt; パッケージ(UiPath Studio)</description></item><item><title>uipath ノート（二）- Best Practice</title><link>https://www.takuzen.me/posts/2019-11-18-uipath-best-practice/</link><pubDate>Mon, 18 Nov 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-11-18-uipath-best-practice/</guid><description>時間をかけて各ワークフローに適したレイアウトを選択しましょう。 メイン: フローチャートまたはステートマシン
ビジネスロジック: フローチャート
UI インタラクション: シーケンス
フローチャートを使用することで、入れ子状の IF を回避
プロセスを小さなワークフローに分割しましょう。 分割したものを個別に開発、テスト
ワークフローの再利用
分割ファイルで作業することによる、より効率的な共同作業
必ず例外を処理しましょう。 例外が発生しやすいワークフローを [Try Catch (トライキャッチ)] ブロックに配置
外部から呼び出されたワークフローでも同様
リカバリシーケンスの設定
ワークフローを読みやすいものにしましょう。 すべてのコンポーネントにわかりやすい名前を選択
注記やコメントの使用
リアルタイムの実行状況のログ取得
環境設定を Config ファイルに格納
不要になったアプリケーションを終了させることで、常にクリーンな状態を維持しましょう。</description></item><item><title>JavaScript URI エンコーディング</title><link>https://www.takuzen.me/posts/2019-11-10-encodeuricomponent/</link><pubDate>Sun, 10 Nov 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-11-10-encodeuricomponent/</guid><description>まとめ encodeURI()とencodeURIComponent()はRFC 2396準拠である。 encodeURI() は完全な URI を表すのに必要な文字 (Reserved Characters) はエンコードしません。 また、予約されていないが &amp;ldquo;そのまま&amp;rdquo; URI に使用できる(Unreserved Marks) 文字をエンコードしません。 encodeURIComponent() は &amp;ldquo;Unreserved Marks&amp;rdquo; 文字をエンコードしません。
var set1 = &amp;#34;;,/?:@&amp;amp;=+$#&amp;#34;; // Reserved Characters var set2 = &amp;#34;-_.!~*&amp;#39;()&amp;#34;; // Unreserved Marks console.log(encodeURI(set1)); // ;,/?:@&amp;amp;=+$ console.log(encodeURI(set2)); // -_.!~*&amp;#39;() console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24 console.log(encodeURIComponent(set2)); // -_.!~*&amp;#39;() rfc2396 appendix-A https://tools.ietf.org/html/rfc2396#appendix-A
URI-reference = [ absoluteURI | relativeURI ] [ &amp;quot;#&amp;quot; fragment ] absoluteURI = scheme &amp;quot;:&amp;quot; ( hier_part | opaque_part ) relativeURI = ( net_path | abs_path | rel_path ) [ &amp;quot;?</description></item><item><title>uipath ノート（一）</title><link>https://www.takuzen.me/posts/2019-10-27-uipath/</link><pubDate>Sun, 27 Oct 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-10-27-uipath/</guid><description>変数 Int32 String Boolean GenericValue　参照 UiPath Studio には GenericValue 変数の自動変換メカニズムがあり、式を正しく定義することで、目的の結果を得ることができます。式の最初の要素は、Studio から操作するガイドラインとして使用されることを考慮してください。例えば、2 つの GenericValue 変数を追加し、式の最初の変数が String として定義されてた場合、最初に代入された値を元に 2 つの値を結合し、文字列となります。 Integer として定義した場合の結果は、合計の値となります。
Array DataTime DataTable .Net 変数型を参照して探す方法
アクティビティ レイアウトダイアグラム シーエンス：　より高度で複雑な自動化に向こう フローチャート：　シンプルな自動化プロジェクトに適している ステートマシン Global Exception Handler (グローバル例外ハンドラー) 参照：https://docs.uipath.com/studio/lang-ja/docs/workflow-design
選択肢 条件分岐(If)：　シーケンス用条件分岐 フロー条件分岐(flow desicion)：　フローチャート用条件分岐 フロースイッチ (Flow Switch) 繰り返し 繰り返し（前判定）(While) 繰り返し（後判定）(Do While) 繰り返し（コレクションの各要素）(For Each) データ操作 CSVを読み込み(Read CSV) オプションにエンコーディングを指定できる（日本語データがある場合、&amp;quot;SHIFT-JIS&amp;quot;を指定する） 列名を含める(IncludeColumnNames)を指定できる 出力タイプ：System.</description></item><item><title>JavaScript Comparison operation at a glance</title><link>https://www.takuzen.me/posts/2019-03-28-javascript-comparison/</link><pubDate>Thu, 28 Mar 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-03-28-javascript-comparison/</guid><description>When given a scenario like:
console.log(null &amp;gt; -1) //true It produces true, which makes me think null is treated as 0. But when I run:
console.log(null == 0) // false console.log(null &amp;gt; 0) // false console.log(null &amp;lt; 0) // false They all output false!
I googled a lot and finally found answers in Ecma-262 Specification.
The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:</description></item><item><title>Js tips I can't remember</title><link>https://www.takuzen.me/posts/2019-03-22-js-tips/</link><pubDate>Fri, 22 Mar 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-03-22-js-tips/</guid><description>&lt;h2 id="__proto__-vs-prototype">&lt;code>__proto__&lt;/code> VS &lt;code>prototype&lt;/code>&lt;/h2>
&lt;blockquote>
&lt;p>&lt;code>__proto__&lt;/code> is the actual object that is used in the lookup chain to resolve methods and others. &lt;code>prototype&lt;/code> is the object that is used to build &lt;code>__proto__&lt;/code> when creating an object with &lt;code>new&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>The &amp;ldquo;cool kids&amp;rdquo; in JavaScript would generally pronounce &lt;code>__proto__&lt;/code> as &amp;ldquo;&lt;strong>dunder proto&lt;/strong>&amp;rdquo;.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript">https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">( &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Foo&lt;/span> ).&lt;span style="color:#ae81ff">__&lt;/span>&lt;span style="color:#a6e22e">proto__&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">Foo&lt;/span>.&lt;span style="color:#a6e22e">prototype&lt;/span>; &lt;span style="color:#75715e">// true
&lt;/span>&lt;span style="color:#75715e">&lt;/span>( &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Foo&lt;/span> ).&lt;span style="color:#a6e22e">prototype&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>; &lt;span style="color:#75715e">// true
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Object.assign() with accessor descriptor</title><link>https://www.takuzen.me/posts/2019-03-08-object-assign-with-accessor-descriptor/</link><pubDate>Fri, 08 Mar 2019 10:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-03-08-object-assign-with-accessor-descriptor/</guid><description>&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Copying_accessors">MDN docs:&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>The Object.assign() method only copies enumerable and own properties from a source object to a target object. It uses [[Get]] on the source and [[Set]] on the target, so it will invoke getters and setters. Therefore it assigns properties versus just copying or defining new properties. This may make it unsuitable for merging new properties into a prototype if the merge sources contain getters.&lt;/p>
&lt;/blockquote>
&lt;p>For example&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cat&lt;/span> {
&lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#ae81ff">_&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>;
}
&lt;span style="color:#a6e22e">get&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>() {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#ae81ff">_&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>;
}
&lt;span style="color:#a6e22e">set&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>(&lt;span style="color:#a6e22e">value&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#ae81ff">_&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">value&lt;/span>;
}
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">nyannko&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Cat&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;nyannko&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Object.&lt;span style="color:#a6e22e">assign&lt;/span>({}, &lt;span style="color:#a6e22e">nyannko&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">nyannko&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>) &lt;span style="color:#75715e">// nyannko
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">copy&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>) &lt;span style="color:#75715e">// undefined
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>name&lt;/code> property is lost.&lt;/p></description></item><item><title>Bind specific arguments of a function</title><link>https://www.takuzen.me/posts/2019-03-08-es6-bind-trick/</link><pubDate>Fri, 08 Mar 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-03-08-es6-bind-trick/</guid><description>To bind specific (nth) arguments of a function, we can write a decorator instead of using Function.bind():
function func(p1, p2, p3) { console.log(p1, p2, p3); } // the binding starts after however many are passed in. function decorator(...bound_args) { return function(...args) { return func(...args, ...bound_args); }; } // bind the last parameter let f = decorator(&amp;#34;3&amp;#34;); f(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;); // a b 3 // bind the last two parameter let f2 = decorator(&amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;) f2(&amp;#34;a&amp;#34;); // a 2 3 Even if we want to bind just the nth argument, we can do as follows:</description></item><item><title>VueのNavigation Guards</title><link>https://www.takuzen.me/posts/2019-01-19-vue-navigation-guards/</link><pubDate>Fri, 25 Jan 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-01-19-vue-navigation-guards/</guid><description>Navigation guards are provided by vue-router. Three ways to hook:
globally per-route in-component NOTE:
Params or query changes won&amp;rsquo;t trigger enter/leave navigation guards. You can either watch the $route object to react to those changes, or use the beforeRouteUpdate in-component guard. Make sure to always call the next function, otherwise the hook will never be resolved. Global const router = new VueRouter({ ... }) // Before Guards router.</description></item><item><title>ES6について</title><link>https://www.takuzen.me/posts/2019-01-18-es6/</link><pubDate>Fri, 18 Jan 2019 16:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-01-18-es6/</guid><description>&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>&lt;a href="https://github.com/lukehoban/es6features#readme">https://github.com/lukehoban/es6features#readme&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://help.wtf/es6">http://help.wtf/es6&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://es6-features.org">http://es6-features.org&lt;/a>&lt;/p>
&lt;h2 id="string">String&lt;/h2>
&lt;h3 id="stringx-is-deprecated-use-stringprototypex-instead">String.x is deprecated; use String.prototype.x instead.&lt;/h3>
&lt;p>非推奨の構文:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Javascript" data-lang="Javascript">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">num&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">15&lt;/span>;
String.&lt;span style="color:#a6e22e">replace&lt;/span>(&lt;span style="color:#a6e22e">num&lt;/span>, &lt;span style="color:#e6db74">/5/&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;2&amp;#39;&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>標準の構文:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Javascript" data-lang="Javascript">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">num&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">15&lt;/span>;
String(&lt;span style="color:#a6e22e">num&lt;/span>).&lt;span style="color:#a6e22e">replace&lt;/span>(&lt;span style="color:#e6db74">/5/&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;2&amp;#39;&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="template-literal">Template literal&lt;/h3>
&lt;p>Nesting templates:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Javascript" data-lang="Javascript">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">classes&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">`header &lt;/span>&lt;span style="color:#e6db74">${&lt;/span> &lt;span style="color:#a6e22e">isLargeScreen&lt;/span>() &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">`icon-&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">item&lt;/span>.&lt;span style="color:#a6e22e">isCollapsed&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#39;expander&amp;#39;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;collapser&amp;#39;&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span> &lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>;
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>SpringMVC初使用心得</title><link>https://www.takuzen.me/posts/2018-10-10-springmvc-practice/</link><pubDate>Wed, 10 Oct 2018 17:25:25 +0000</pubDate><guid>https://www.takuzen.me/posts/2018-10-10-springmvc-practice/</guid><description>进入公司第一个实践的项目是用SpringMVC开发的。在前辈指导跳过了Spring庞大的学习内容直接上手了SpringMVC。磕磕碰碰中也算是对Spring有了一个初步的了解。
SpringMVC框架初识 SpringMVC是Spring提供的一个web框架。
架构 SpringMVC是Spring的一部分，主要模块如下图所示。
在SpringMVC为架构的项目中的代码逻辑主要有如下几层:
Controller层 Controller层起到了路由的作用，通过Spring提供的@RequestMapping注解将请求路径和请求方法（GET/POST等）与Controller的方法绑定，接受请求参数，进行验证权限等操作并调用Service执行业务逻辑。Controller类需要表明@Controller注解。
Service层 Service层实现了业务的主要逻辑。处理参数，调用负责数据库操作的Dao层，组装返回数据并将结果返回给Controller。Service类需要标注@Service注解。
Dao层 Data access的部分在项目中体现为Dao层。Dao层的类以Model为载体，借助JDBC或者Hibernate的方法封装了对表的各种操作。通常Dao层的类和数据表是一一对应的。Dao层的类需要添加@Repository注解。
Model Model层就是数据表的Java载体。需要添加@Entity注解标明该类为实体，并使用@Table(name = &amp;quot;table_name&amp;quot;)来绑定数据表。Model类中要添加@Id @GeneratedValue注解配置主键（具体含义还需进一步学习。参考链接:https://www.baeldung.com/hibernate-identifiers https://www.thoughts-on-java.org/jpa-generate-primary-keys/。）Model中的getter setter通过@Column(name = &amp;quot;id&amp;quot;, unique = true, nullable = false)注解表字段。
调度流程 首先在项目最外层的web.xml中指定了Spring提供的dispatcherServlet作为调度请求的核心servlet。
未完待续</description></item><item><title>Android配置变更时的状态保留</title><link>https://www.takuzen.me/posts/2017-10-25-save-stats-through-configuration-changes/</link><pubDate>Wed, 25 Oct 2017 03:59:14 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-10-25-save-stats-through-configuration-changes/</guid><description>在设备配置变化时，Android会销毁并重建正在运行的 Activity， 通常使用 onSaveInstanceState()，来保存有关应用状态的数据。 然后，可以在 onCreate() 或 onRestoreInstanceState() 期间恢复 Activity 状态。
但是，在有些情况下，如在执行一段耗时的异步网络请求，onSaveInstanceState()就显得力不从心了，只能重新执行异步操作。这样不但影响用户体验，处理不慎还可能会使应用异常终止。
文档中推荐使用 Fragment 来保留有状态对象的引用。通过 setRetainInstance(true) 方法，系统不会在重启活动时销毁fragment。
public class RetainedFragment extends Fragment { // data object we want to retain private MyDataObject data; // this method is only called once for this fragment @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // retain this fragment setRetainInstance(true); } public void setData(MyDataObject data) { this.data = data; } public MyDataObject getData() { return data; } } 在添加fragment时定义一个标签以便恢复。</description></item><item><title>get-selected-text-from-webview</title><link>https://www.takuzen.me/posts/2017-10-08-get-selected-text-from-webview/</link><pubDate>Sun, 08 Oct 2017 00:30:19 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-10-08-get-selected-text-from-webview/</guid><description>在试图自定义WebView选择文本之后的行为时，遇到了很多的麻烦。
首先便是获得选择文本这一步。WebView并没有相应的API，想获取选择的文本貌似只能通过js来解决。在最开始的尝试中，我的代码实现如下：
contentText.loadDataWithBaseURL(null, article.getContent(), &amp;#34;text/html&amp;#34;, &amp;#34;UTF-8&amp;#34;, null); contentText.evaluateJavascript(&amp;#34;(function(){return window.getSelection().toString()})()&amp;#34;, new ValueCallback&amp;lt;String&amp;gt;() { @Override public void onReceiveValue(String s) { Log.d(&amp;#34;NewsContentActivity&amp;#34;, s); } }); 然而不知为何，获取到的文本始终为空字符串&amp;quot;&amp;quot;，百思不得其解的我偶然把evaluateJavascript方法放到了重写的onActionModeStarted中，竟然可以收到正确的文本了，不过依然有个严重的问题：在当前WebView中只能成功获取一次，再次选择文本就完全没有反应了。在调试时我发现，是因为我在选择文本时要先点击屏幕使得之前的选择消除掉，否则始终是同一次的onActionModeStarted调用。这样就无法解决我的问题了，因为我需要获取拖拽浮标选择的文本。
。。。
研究了一夜，实在没什么方案可以达到我想要的效果，只能通过点击菜单项获取选择的文本了。。
未完待续。</description></item><item><title>提升ListView的效率</title><link>https://www.takuzen.me/posts/2017-10-04-making-listview-scrolling-smooth/</link><pubDate>Wed, 04 Oct 2017 04:52:18 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-10-04-making-listview-scrolling-smooth/</guid><description>利用好getView中的convertView参数 getView()方法中有一个convertView参数用来缓存已经加载好的布局，从而我们可以在代码中对布局进行重用：
public View getView(int position, View convertView, ViewGroup parent) { View view = convertView; if (view == null) view = LayoutInflater.from(getContext()).inflate(resorceId, parent, false); // ... } 使用ViewHolder 定义ViewHolder来存储已经获取的Views实例。
class ViewHolder { TextView textView; ImageView imageView; // ... } public View getView(int position, View convertView, ViewGroup parent) { View view = convertView; VIewHolder holder; if (view == null) { view = LayoutInflater.from(getContext()).inflate(resorceId, parent, false); holder = new ViewHolder(); // save views to the holder.</description></item><item><title>Android中的MVP模式</title><link>https://www.takuzen.me/posts/2017-09-29-mvp-in-android/</link><pubDate>Fri, 29 Sep 2017 15:18:32 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-09-29-mvp-in-android/</guid><description>Model View Presenter (MVP) 模式是安卓开发中非常热门的一种架构模式。MVP模式将数据模型从传统的View层分离出来，通过presenter实现两者的间接通信。
(图片出处：vogella)
View层 该层专注于UI的实现，实现UI操作的接口，如showProgressBar, updateData等。通常会持有对Presenter层的引用，或通过依赖注入获取到Presenter实例。 Presenter层 该层实现业务逻辑，负责View层和Model层的控制和交互。该层通常应尽量避变对sdk产生依赖。 Model层 该层实现对数据操作的封装，暴露接口给Presenter层。</description></item><item><title>Android Webview中的编码问题</title><link>https://www.takuzen.me/posts/2017-09-24-encoding-in-webview/</link><pubDate>Sun, 24 Sep 2017 20:11:30 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-09-24-encoding-in-webview/</guid><description>最近在处理一段html文本时，为了解析ruby标签，我用Weview代替了Textview，起初是这样写的：
webview.loadData(article.getContent(), &amp;#34;text/html&amp;#34;, &amp;#34;UTF-8&amp;#34;); 结果显示出来全部是乱码。网上查阅资料后发现一个一简易的处理办法：
contentText.loadData(article.getContent(), &amp;#34;text/html; charset=UTF-8&amp;#34;, &amp;#34;UTF-8&amp;#34;); 我处理的文本是含有日语的html文本，这个方法是有效的。
另外，也可以使用WebView.loadDataWithBaseURL()代替WebView.loadData()。
webview.loadDataWithBaseURL(null, article.getContent(), &amp;#34;text/html&amp;#34;, &amp;#34;UTF-8&amp;#34;, null); 网上还有这样的方法：
if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.FROYO) { String base64 = Base64.encodeToString(htmlString.getBytes(), Base64.DEFAULT); myWebView.loadData(base64, &amp;quot;text/html; charset=utf-8&amp;quot;, &amp;quot;base64&amp;quot;); } 如代码中所见，该方法适用于Android 4+的场景。不过我并没有进行实际测试这种方式。
参考资料 stackoverflow - Android. WebView and loadData Android Developers</description></item><item><title>使用Tools Attributes Reference</title><link>https://www.takuzen.me/posts/2017-09-23-use-tools-attributes-reference-in-android-studio/</link><pubDate>Sat, 23 Sep 2017 19:55:32 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-09-23-use-tools-attributes-reference-in-android-studio/</guid><description>Android Studio 提供了一系列工具属性用于开发过程中，如预览布局效果等。构建应用时会自动删除掉所有此类属性。灵活应用这些属性可以给开发带来很大的快感。
为启用此类属性，加入toolsNs即可。
&amp;lt;RootTag xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; &amp;gt; 使用tools:前缀代替android: 由于经常会在代码中对布局进行更改，无法通过IDE的预览功能直观的查看到效果。这时可使用tools:前缀代替android:来插入简单的数据，如tools:text tools:src等。
使用tools:listitem / tools:listheader / tools:listfooter 这些属性可以将item的布局加载出来，帮助我们预览ListView或RecyclerView，而不再是单纯的文本。
还有一些其他属性，待下次用到时再进行记载。
参考资料 文档：Tools Attributes Reference</description></item><item><title>使用Gson解析含有动态未知键名的json数据</title><link>https://www.takuzen.me/posts/2017-09-05-dealing-with-ramdomly-generated-json-key-names-using-gson-md/</link><pubDate>Tue, 05 Sep 2017 14:16:06 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-09-05-dealing-with-ramdomly-generated-json-key-names-using-gson-md/</guid><description>初学Android开发，最近在开发一个用来练手的android小项目，遇到了一个问题：在解析json时遇到了含有未知字段的json数据，此时不能通过Gson库的静态解析方式进行解析。文档上提到了可以自定义解析器，网上也有一些类似的实现案例。我也记录下相应的解决方案。
我获取的json数据可简化为：
// news { news_id: &amp;#34;id&amp;#34;, news_title: &amp;#34;title&amp;#34; } // monthJson { &amp;#34;2017-09-05&amp;#34;: [ { news_id: &amp;#34;id1&amp;#34;, news_title: &amp;#34;title1&amp;#34; }, { news_id: &amp;#34;id2&amp;#34;, news_title: &amp;#34;title2&amp;#34; } ], &amp;#34;2017-09-04&amp;#34;: [ { news_id: &amp;#34;id1&amp;#34;, news_title: &amp;#34;title1&amp;#34; }, { news_id: &amp;#34;id2&amp;#34;, news_title: &amp;#34;title2&amp;#34; } ] } 可建立如下模型（省略 getter 和 setter ）：
public class News { @SerializedName(&amp;#34;news_id&amp;#34;) private String id; @SerializedName(&amp;#34;news_title&amp;#34;) private String title; } public class MonthNews { private Map&amp;lt;String, List&amp;lt;News&amp;gt;&amp;gt; monthNews; public MonthNews(Map&amp;lt;String, List&amp;lt;News&amp;gt;&amp;gt; monthNews) { this.</description></item><item><title>用php://input代替php的$HTTP_RAW_POST_DATA全局变量</title><link>https://www.takuzen.me/posts/2017-09-03-php-http-raw-post-data-feature-md/</link><pubDate>Sun, 03 Sep 2017 04:02:29 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-09-03-php-http-raw-post-data-feature-md/</guid><description>最近在开发一个小微信应用时，发现使用原来的工具代码总是获取不到微信服务器发来的数据。原来的代码中使用$GLOBALS[&amp;quot;HTTP_RAW_POST_DATA&amp;quot;]的方式获取post提交的数据。查了查才发现，HTTP_RAW_POST_DATA 早在php 5.6.0时就已经废弃，到了7.0.0版本已经移除。我的服务器上php是7.0版本，难怪会发生这样的问题。文档中推荐使用php://input的方式代替$HTTP_RAW_POST_DATA获取post数据。
$postdata = file_get_contents(&amp;#34;php://input&amp;#34;); php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。 而且，这样的情况下 $HTTP_RAW_POST_DATA 默认没有填充， 比激活 always_populate_raw_post_data 潜在需要更少的内存。 enctype=&amp;ldquo;multipart/form-data&amp;rdquo; 的时候 php://input 是无效的。
这其实算是自己的问题了。。想偷懒不及时了解php的版本变动真是使不得&amp;gt;&amp;lt;</description></item><item><title>tcp拥塞控制算法总结（含BBR）</title><link>https://www.takuzen.me/posts/2017-05-02-tcp-congestion-control-algorithms/</link><pubDate>Tue, 02 May 2017 15:38:54 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-05-02-tcp-congestion-control-algorithms/</guid><description>Tahoe Tahoe是早期包含在 BCD 4.2 中的一个TCP早期版本。它在连接之初处于慢启动阶段。若遇到丢包事件，无论是超时还是快速重传，都会无条件将cwnd减为1个MSS，重新开始慢启动阶段，将ssthresh减为当前拥塞窗口的一半。对于有较大BDP（带宽延迟积）的链路来说，该方法会使得带宽利用率低下。
Vaegas Vegas算法试图在维持较好吞吐量的同时避免拥塞。它通过观察RTT来预测网络拥塞。当RTT增大时，Vegas认为网络正在发生拥塞，于是线性降低发送速率。利用RTT判断拥塞使得Vegas算法有较高的效率，但也导致采用Vegas的连接有较差的带宽竞争力。
Reno &amp;amp; NewReno Reno算法相当于是Tahoe算法的改进。它综合了快速恢复机制，当检测到快速重传时，Reno算法将cwnd减为当前窗口的一半加上3MSS，并将ssthresh设置为当前窗口的一半，然后cwnd进入线性增长。Reno算法存在的问题是它不能有效解决同一窗口丢失多个分组的情况（局部ACK），可能会严重影响网络吞吐性能。NewReno算法对这一问题进行了改进。它记录了上一个数据传输窗口的最高序列号（ACK恢复点），当结束到的ACK序列号不小于恢复点序列号时才会停止快速恢复阶段。NewReno是目前比较常用的一个TCP版本。
BIC-TCP BIC-TCP算法的主要目的在于，即使在拥塞窗口非常大的情况下也能满足线性RTT公平性。使用二分 搜索增大 和 加法增大 两种算法探测饱和点，通过 最大值探测 机制实现。Linux 2.6.8 至 2.6.17 内核版本中默认开启该算法。
CUBIC CUBIC算法改进了BIC-TCP算法中在某些情况下（低速网络）增长过快的不足，并对窗口增长机制进行了简化。它通过一个三次函数来控制窗口的增长。除此之外CUBIC还有 TCP友好 策略，确保在低速网络中CUBIC的友好性。从Linux 2.6.18 内核版本开始CUBIC成为了Linux默认的TCP拥塞控制算法。
BBR BBR是goole在2016年下半年公开的一种开源拥塞控制算法，已经包含在了Linux 4.9 内核版本中。采用丢包作为拥塞信号的代价就是，在有一定错误丢包率的链路上，标准拥塞控制算法通常会收敛到一个比较小的发送窗口上，并没有占满网络带宽。BBR不再关注丢包作为拥塞信号，而是通过交替测量带宽和延迟，用一段时间内的带宽极大值和延迟极小值作为估计值的乘积作为窗口估计值，因此BBR可以更充分的利用带宽。目前对BBR的评价有褒有贬，有人说时黑科技，有人说其抢占带宽不道德，有人说这是TCP发展的一大进步也是拥塞控制的未来发展方向，还有人说大范围部署BBR将是一场灾难。。。我对TCP/IP的学习还很皮毛，就不贸然站队了。不过我在境外vps上部署了BBR之后，跑在vps上的ss速度提升非常显著，个人来讲还是很喜欢的:).
相关链接 BBR: Congestion-Based Congestion Control https://www.zhihu.com/question/53559433 http://www.cqvip.com/read/read.aspx?id=23783845#</description></item><item><title>有关php内建函数复杂度的一点探究</title><link>https://www.takuzen.me/posts/2017-03-05-performance-of-php-built-in-functions/</link><pubDate>Sun, 05 Mar 2017 00:16:38 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-03-05-performance-of-php-built-in-functions/</guid><description>在用php实现CtCI里面的习题时，算法中常常要用到array_key_exists()方法。然而通常在数组中检索的复杂度为O(n)，那么这是否会对php实现的算法产生比较大的影响呢？
在php的 manual 中有人提到，isset()比array_key_exists()快的多，但是两者对null的处理方式是不一样的。
&amp;lt;?php //test.php $t[&amp;#39;a&amp;#39;] = null; if (isset($t[&amp;#39;a&amp;#39;])) echo &amp;#34;a is set\n&amp;#34;; else echo &amp;#34;a is not set\n&amp;#34;; if (array_key_exists(&amp;#39;a&amp;#39;, $t)) echo &amp;#34;a exists\n&amp;#34;; else echo &amp;#34;a doesn&amp;#39;t exists\n&amp;#34;; // 运行上面的代码，会输出： // a is not set // a exists 在开发中可以采用如下方法：
if (isset(..) || array_key_exists(...)) { ... } 大大提升了运行速度又保证了结果。
Benchmark (100000 runs): array_key_exists() : 205 ms is_set() : 35ms isset() || array_key_exists() : 48ms
另外 stackoverflow 上有人对array_*的复杂度做过一番调查：</description></item><item><title>常用算法总结</title><link>https://www.takuzen.me/posts/2017-02-24-common-sorting-algorithms/</link><pubDate>Fri, 24 Feb 2017 19:47:40 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-02-24-common-sorting-algorithms/</guid><description>基于比较的排序算法的最优性能是O(n log n)
文中代码通用的两个方法：
private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &amp;lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable swap = a[i]; a[i] = a[j]; a[j] = swap; } 插入排序 Time Complexity: O(n ^ 2) 最好情况O(n) 稳定 in place public class Insertion { public static void sort(Comparable[] a) { int N = a.length; for (int i = 0; i &amp;lt; N; i++) for (int j = i; j &amp;gt; 0; j--) if (a[j] &amp;lt; a[j - 1]) { exch(a, j, j-1); } else break; } } 选择排序 Time Complexity: O(n ^ 2) 不稳定 in place public class Selection { public static void sort(Comparable[] a) { int N = a.</description></item><item><title>java散列知识点总结</title><link>https://www.takuzen.me/posts/2017-02-18-hash/</link><pubDate>Sat, 18 Feb 2017 19:19:01 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-02-18-hash/</guid><description>java 的根类 Object 具有 hashcode 方法。当 equal 方法被重写时也应当重写 hashcode 方法。
基本数据类型的散列码 byte short int char 类型的搜索键将会转换为 int。 float 类型的搜索键使用 Float.floatToIntBits(key) 作为散列码。 long 类型的搜索键会进行折叠操作，如下： iny hashCode = (int) (key ^ (key &amp;gt;&amp;gt; 32)); double 类型的搜索键会使用 Double.doubleToLongBits(key) 方法转换为 long 类型然后再进行折叠。 字符串类型的散列码 对于字符串一般使用多项式散列码进行计算，
这里放个公式的图
b的较好取值为31，33，37，39，41。在 java String 类中 b 取31。
public static int hash(String key, int tableSize) { int hashVal = 0; for (int i = 0; i &amp;lt; key.</description></item><item><title>Algorithms part1 programming assignments 2 - deque</title><link>https://www.takuzen.me/posts/2017-02-10-algorithms-part1-assignments-2-deque/</link><pubDate>Fri, 10 Feb 2017 18:33:59 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-02-10-algorithms-part1-assignments-2-deque/</guid><description>这次作业内容是关于栈和队列的。要求为实现两种数据类型：deque 和 randomized queues。
Deque Deque: A double-ended queue or deque (pronounced &amp;ldquo;deck&amp;rdquo;) is a generalization of a stack and a queue that supports adding and removing items from either the front or the back of the data structure.
deque就是个双向队列，从两头都可以添加和删除。用链表实现起来比较方便。要求的api如下：
public class Deque&amp;lt;Item&amp;gt; implements Iterable&amp;lt;Item&amp;gt; { public Deque() // construct an empty deque public boolean isEmpty() // is the deque empty? public int size() // return the number of items on the deque public void addFirst(Item item) // add the item to the front public void addLast(Item item) // add the item to the end public Item removeFirst() // remove and return the item from the front public Item removeLast() // remove and return the item from the end public Iterator&amp;lt;Item&amp;gt; iterator() // return an iterator over items in order from front to end public static void main(String[] args) // unit testing (optional) } 题目要求每个deque的操作都必须是 O(1) 的时间复杂度，迭代器的操作也是 O(1) 的时间复杂度。包含n个元素的deque最多占用48n + 192 bytes。综合考虑采用双向链表比较合适。</description></item><item><title>Algorithms part1 programming assignments 1 - Percolation</title><link>https://www.takuzen.me/posts/2017-02-08-algorithms-part1-programming-assignments-1/</link><pubDate>Wed, 08 Feb 2017 20:48:32 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-02-08-algorithms-part1-programming-assignments-1/</guid><description>坚持看了很久的algorithms公开课，终于决定回过头来整理一下作业。。 这次作业解决的是渗滤系统的阈值问题。渗滤（percolation)是一个常见的物理系统，描述为：
We model a percolation system using an n-by-n grid of sites. Each site is either open or blocked. A full site is an open site that can be connected to an open site in the top row via a chain of neighboring (left, right, up, down) open sites. We say the system percolates if there is a full site in the bottom row. In other words, a system percolates if we fill all open sites connected to the top row and that process fills some open site on the bottom row.</description></item><item><title>php的闭包特性</title><link>https://www.takuzen.me/posts/2017-01-11-php-lambada/</link><pubDate>Wed, 11 Jan 2017 18:39:17 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-01-11-php-lambada/</guid><description>闭包和匿名函数在PHP 5.3.0引入，并且PHP将两者视为相同的概念。闭包其实是伪装成函数的对象，它的实质其实是Closure实例。
创建闭包非常简单：
$c = function($name) { return sprintf(&amp;#34;Hello World! Hello %s!&amp;#34;, $name); }; echo $c(&amp;#39;PHP&amp;#39;); 使用use对闭包附加状态，多个参数使用,分隔：
function callPerson($name) { return function($about) use ($name) { return sprintf(&amp;#34;%s, %s&amp;#34;, $name, $about); } } $triver = callPerson(&amp;#39;Triver&amp;#39;); echo $triver(&amp;#34;slow down, please!!&amp;#34;); 附加的变量会被封装到闭包内，即使返回的闭包队形已经跳出了callPerson()的作用域也仍然会记住$name的值。
闭包有一个有趣的bindTo()方法，可以将闭包的内部状态绑定到其他对象上，第二个参数指定了绑定闭包的对象所属的类，从而实现在闭包中访问绑定对象的私有方法和属性。
class Bind { protected $name = &amp;#39;no name&amp;#39;; public $change; public function addAction($action) { $this-&amp;gt;change = $action-&amp;gt;bindTo($this, __CLASS__); } } $bind = new Bind(); $bind-&amp;gt;addAction(function() { $this-&amp;gt;name = &amp;#34;php&amp;#34;; return $this-&amp;gt;name; }); $change = $bind-&amp;gt;change; echo $change(); 使用这个特性可以方便的为类添加方法并绑定：</description></item><item><title>ruby学习笔记</title><link>https://www.takuzen.me/posts/2016-12-08-ruby-notes/</link><pubDate>Thu, 08 Dec 2016 22:54:49 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-12-08-ruby-notes/</guid><description>regular expressions =~是用于正则表达式的匹配操作符。返回匹配到的字符串位置或nil。
&amp;#34;abcdef&amp;#34; =~ /d/ # return 3 &amp;#34;aaaaaa&amp;#34; =~ /d/ # return nil !和? The exclamation point (!, sometimes pronounced aloud as &amp;ldquo;bang!&amp;quot;) indicates something potentially destructive, that is to say, something that can change the value of what it touches.
ruby&amp;gt; s1 = &amp;quot;forth&amp;quot; &amp;quot;forth&amp;quot; ruby&amp;gt; s1.chop! # This changes s1. &amp;quot;fort&amp;quot; ruby&amp;gt; s2 = s1.chop # This puts a changed copy in s2, &amp;quot;for&amp;quot; ruby&amp;gt; s1 # .</description></item><item><title>netfilter/iptables 笔记</title><link>https://www.takuzen.me/posts/2016-11-29-iptables-usage/</link><pubDate>Tue, 29 Nov 2016 21:08:52 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-11-29-iptables-usage/</guid><description>netfilter 与 iptables netfilter是linux默认的防火墙，在2.4之后的版本正式进入内核。netfilter 使用四个表(Table)来存放控制信息包过滤处理的规则集。每张表由链(Chain)组成，每条链又包含了多条规则(rule)。
iptables是用来编辑操作这些表的一个工具。iptables包中也包含了针对IPv6的工具ip6tables。
四个表及其包含的链：
filter INPUT FORWARD OUTPUT nat PREROUTING POSTROUTING OUTPUT mangle PREROUTING INPUT FORWARD OUTPUT POSTROUTING raw PREROUTING OUTPUT filter机制 filter是netfilter中最重要的机制，其任务是执行数据包的过滤操作。具有三种内建链：
INPUT - 来自外部的数据包（访问本机） OUTPUT - 发往外部的数据包（本机访问外部） FORWORD - “路过”本机的数据包，转发到其他设备 链中规则的匹配方式遵循first match。filter会根据数据包特征从相应链中的第一条规则开始逐一进行匹配。只要遇到满足特征的规则后便不再继续。 每条链在最底端都定义了默认规则。默认规则只会有一种状态：ACCEPT或者DROP。默认为ACCEPT。
iptables命令参数 格式：
iptables -操作方式 [链名] [条件匹配] [选项] iptables -[ACD] chain rule-specification [options] iptables -I chain [rulenum] rule-specification [options] iptables -R chain rulenum rule-specification [options] iptables -D chain rulenum [options] iptables -[LS] [chain [rulenum]] [options] iptables -[FZ] [chain] [options] iptables -[NX] chain iptables -E old-chain-name new-chain-name iptables -P chain target [options] iptables -h (print this help information) 常用操作方式：</description></item><item><title>hexo博客突然丢失了所有的css js？？</title><link>https://www.takuzen.me/posts/2016-11-05-hexo-vendors-folder-missing/</link><pubDate>Sat, 05 Nov 2016 14:31:16 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-11-05-hexo-vendors-folder-missing/</guid><description>我这个博客使用Github Pages + hexo + next主题，昨天提交一篇博客之后就跪了，看不见文章列表，控制台里发现所有在vendor目录下的css和js全部404。纠结了一下午终于在github上找到了这个问题的issue
We recently updated to Jekyll v3.3, which ignores the vendor folder by default. If you&amp;rsquo;re not using Jekyll, you can add a .nojekyll file to the root of your repository to disable Jekyll from building your site. Once you do that, your site should build with your vendor folder.
原来是github最近升级了Jekyll，升级之后会默认忽略vendor/vendors文件夹。。这个会直接影响到next主题的显示。
目前找到了这么几种解决办法：
官方给出的解决办法就是在根目录下添加一个.nojekyll文件，对于hexo的话需要在.deploy_git和public目录下添加，然后hexo d即可。 更新next主题，作者已提交针对此问题的更新。 手动将 source/vendors 目录修改成 source/lib 或者其他的名称；同时，修改下主题配置文件_config.yml， 将 _internal: vendors 改成你所修改的名字 相关链接:</description></item><item><title>composer中的autoload</title><link>https://www.takuzen.me/posts/2016-11-05-php-composer-autoload/</link><pubDate>Sat, 05 Nov 2016 02:42:06 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-11-05-php-composer-autoload/</guid><description>composer的autoload可以轻松的实现php的自动加载。在composer.json中添加autoload字段即可。当前支持 PSR-0 PSR-4 classmap解析和files包含。官方推荐PSR-4标准（添加类时不需要重新生成加载器）。
PSR-4 Under the psr-4 key you define a mapping from namespaces to paths, relative to the package root. When autoloading a class like Foo\\Bar\\Baz a namespace prefix Foo\\ pointing to a directory src/ means that the autoloader will look for a file named src/Bar/Baz.php and include it if present. Note that as opposed to the older PSR-0 style, the prefix (Foo\\) is not present in the file path.</description></item><item><title>幸せ</title><link>https://www.takuzen.me/posts/2016-10-22-z/</link><pubDate>Sat, 22 Oct 2016 16:56:54 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-10-22-z/</guid><description>:-)
Look at the stars
抬头仰望满天繁星
Look how they shine for you
看它们为你绽放着 闪烁不息
And everything you do
而你的一颦一举
Yeah' they were all Yellow
却满含胆怯和羞意
I came along
我追随着你的气息
I wrote a song for you
为你写下一首歌曲
And all the things you do
回想着你的所有举动和笑意
it was called Yellow
并用Yellow为这首歌命名
So then I took my turn
我耗尽心力
Oh what a thing to have done
用行动表达我的爱意
And it was all Yellow
噢这过程充满不安羞怯和点滴暖意
Your skin</description></item><item><title>ssh反向代理实现内网穿透（比较失败( ˙灬˙ )）</title><link>https://www.takuzen.me/posts/2016-10-08-ssh-reverse-proxy/</link><pubDate>Sat, 08 Oct 2016 14:45:08 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-10-08-ssh-reverse-proxy/</guid><description>有关背景请参见http://www.upwzr.com/2016/10/08/run-ngrok/，本文是在使用ngrok之前的依次失败的尝试。。。当然，ngrok实际上也是是ssh来实现的。
对于内网主机想要外网访问，最简单的办法当然是在路由器上做手脚，但是在不能操作路由设备的时候（比如说学校的内网网段），想要实现外网访问可通过ssh隧道实现。只需要一条很简单的命令：
ssh -N -f -R 80:127.0.0.1:8001 root@123.45.67.89 -N 不执行远程命令 -f 后台执行 -R remote_port:localhost:local_port 远程端口转发 上面的命令就表示连接到123.45.67.89，将本地的8001端口转发到123.45.67.89的80端口。公网主机的80端口转发必须使用root权限，用root角色去连接公网主机。 -g (GatewayPorts) option 先贴出一段鸟文：
When you forward a TCP port (either locally or remotely), by default SSH only listens for connections to the forwarded port on the loopback address (localhost, 127.0.0.1). This means only other programs running on the same host as the listening side of the forwarding can connect to the forwarded port.</description></item><item><title>搭建自己的ngrok服务实现内网穿透</title><link>https://www.takuzen.me/posts/2016-10-08-run-ngrok/</link><pubDate>Sat, 08 Oct 2016 12:41:33 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-10-08-run-ngrok/</guid><description>学校有台服务器上跑我们的自己用的gitlab，然而分配的ip是内网网段，在校外或者使用手机流量就没办法访问，跟信管中心申请公网ip又得看他们脸色( ∙̆ .̯ ∙̆ )。尝试了直接用ssh做反向代理，感觉效果不是很满意，不太稳定时常掉线，而且由于腾讯云的坑爹限制，没办法转发到公网80端口上。后来发现了一款神器ngrok，官网提供了收费的转发服务，国内也有不少热心童鞋提供了免费的ngrok服务。不过ngrok 1.x 的版本是开源的，干脆自力更生，搭建自己的ngrok服务。
准备 首先最重要的当然是得有一台公网主机，我的是腾讯云的vps；然后内网主机需要保证可以访问外网（废话），然后要有个域名，绑定到公网ip上。最好做下泛解析，也就是添加一条形如*.yourdomain.xxx的A记录。 公网主机有些环境要配置好，下面这几个包要安装上，为了后面能够顺利的编译ngrok源码（以ubuntu为例）：
sudo add-apt-repository ppa:ubuntu-lxc/lxd-stable sudo apt-get update sudo apt-get install golang sudo apt-get install build-essential mercurial git ngrok使用go写的，所以上面安装了golang环境。有时因为友好的GFW，可能会获取不到源，可参见这个Go 安装
安装ngrok 获取源码 git clone https://github.com/inconshreveable/ngrok.git ngrok cd ngrok export GOPATH=~/ngrok # 也就是刚刚获取的源码位置 最后一句是go环境的配置，跳过不执行应该也可以，没试过。
生成自签名证书 注意第二步和第五步中要替换你自己的域名。
openssl genrsa -out rootCA.key 2048 openssl req -x509 -new -nodes -key rootCA.key -subj &amp;quot;/CN=upwzr.com&amp;quot; -days 5000 -out rootCA.pem openssl genrsa -out device.key 2048 openssl req -new -key device.</description></item><item><title>laravel 5.2 事件广播</title><link>https://www.takuzen.me/posts/2016-10-08-laravel-event-broadcast/</link><pubDate>Sat, 08 Oct 2016 00:38:47 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-10-08-laravel-event-broadcast/</guid><description>简介 Laravel 事件提供了简单的观察者模式实现，允许你订阅和监听应用中的事件。事件类通常存放在 app/Events 目录，监听器存放在 app/Listeners。
配置 所有的事件广播配置选项都存放在 config/broadcasting.php 配置文件中。Laravel 支持多种广播驱动：Pusher、Redis以及一个服务于本地开发和调试的Log日志驱动。每一个驱动都已经有一个配置示例。基本上所有配置信息全可以在.env中指定，不需要改动broadcasting.php配置文件，如：
#在.env中配置驱动 BROADCAST_DRIVER=redis 注册事件和监听器 Laravel 自带的 EventServiceProvider（在 app/Providers/EventServiceProvider.php 中） 为事件注册提供了方便之所。其中的 listen 属性包含了事件（键）和对应监听器（值）数组。如果应用需要，你可以添加多个事件到该数组。例如，让我们添加 SomeEvent 事件：
/** * 事件监听器映射 * * @var array */ protected $listen = [ 'App\Events\SomeEvent' =&amp;gt; [ 'App\Listeners\SomeEventListener', ], ]; 接下来使用event:generate命令生成对应的事件和监听器：
php artisan event:generate 执行后将会创建app/Events/SomeEvent.php 和 app/Listener/SomeEventListener.php。
除了上面在 EventServiceProvider 中注册事件的方式，还可以使用 Event 门面或者 Illuminate\Contracts\Events\Dispatcher 契约的具体实现类作为事件分发器手动注册事件：
/** * Register any other events for your application. * * @param \Illuminate\Contracts\Events\Dispatcher $events * @return void */ public function boot(DispatcherContract $events) { parent::boot($events); $events-&amp;gt;listen('event.</description></item><item><title>暑假越南行（经验篇）</title><link>https://www.takuzen.me/posts/2016-09-02-vietnam-experience/</link><pubDate>Fri, 02 Sep 2016 03:14:41 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-09-02-vietnam-experience/</guid><description>友情链接 想阅读我的游记请移步：（多图预警） 暑假越南行（一）南宁-&amp;gt;河内 暑假越南行（二）顺化-&amp;gt;岘港
未完： 暑假越南行（三）芽庄-&amp;gt;大叻 暑假越南行（四）美奈-&amp;gt;胡志明
__2016.11.10:__这两个大坑不知道我什么时候才会填上。。。
交通 在河内胡志明完全可以多做公交车。人很少，票价一般在7000盾左右。会有很贴近本地人的体验。 顺化到岘港这一段路一定要坐火车体验，非常有特色，无论是火车还是景色。哪怕你没有经过顺化直接到了岘港（从北往南玩的方向），从岘港坐到顺化再回来也是值得的。 岘港到会安在地图上显示只有20多公里，骑摩托车过去的话大概需要接近1个小时（40左右的时速）。 钱和银行卡 可以在金店换钱，河内三十六行街上有无数金店，汇率跟在友谊关基本是一样的。越往南方城市的金店汇率可能会越低。 胡志明机场的汇率很高。如果是直接飞到胡志明往北玩的同学，可以在胡志明机场换钱。 在标有银联标识的pos机上刷卡是不收任何手续费的。花多少钱扣多少钱。乐天超市、Big C、Vinmart、circle K 等等在越南比较常见的超市和便利店里直接刷卡会划算一些。 办一张华夏的卡感觉还是有必要的，每天第一笔取款不收各种手续费。这样就不用像我一样带了一路的人民币。。而且在ATM上取钱是实时汇率转换过来的，比直接换钱要划算。 给钱的时候要看好有几个零。。 物价 基本上除了在正规超市便利店之类的地方，商贩给你的价格跟本地人是不一样的。只能接受，砍价。 东西的价格合不合理，其实主要看自己心情。差不多的东西你觉得比国内便宜不少，那就干脆快乐地接受。 芽庄的榴莲和椰子很便宜。美奈的火龙果非常便宜。 上一条的经验当然不是指在旅游区，要到当地百姓实际生活的区域。尤其是芽庄，只要稍微离开酒店几条街就差不多。美奈的话，基本就是一条长长的街加上那个渔村，纯是面向游客的。 我非常建议各位在到每一个城市的时候，都先去正规一点的超市考察一下物价。尤其是水果的价格，外面的市场不可能会比超市要高。实际上我发现酸奶、矿泉水、咖啡、泡面等等类似的东西在大型超市里面是最便宜的。河内岘港芽庄我去了乐天和big C，胡志明我去了Vinmart。 还要推荐一下大超市里头的法棍，一米多长，只要不到4k（合人民币1块几毛钱）。尤其是刚出锅的(｡￫v￩｡) 未完</description></item><item><title>暑假越南行（二）</title><link>https://www.takuzen.me/posts/2016-09-01-summer-trip-to-vietnam/</link><pubDate>Thu, 01 Sep 2016 03:28:01 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-09-01-summer-trip-to-vietnam/</guid><description>需要看攻略的童鞋请直接跳至经验篇。
2016.8.3 岘港 新咖啡并没有从河内直达岘港的车，所以我实际上买到的是河内-&amp;gt;顺化，顺化-&amp;gt;岘港的车。在顺化只有半个小时的时间，所以并没有玩顺化。 顺化街道 顺化去往岘港的途中。 这里 强烈推荐从顺化到岘港之间的这段路一定要坐一次火车来体检。后面的攻略会具体说。汽车的话会通过好长好长的一段隧道，错过了一段好美好美的景色。
到岘港以后我决定步行去订的青旅，后来发现真的好远。。 远远的就看见这条大黄龙 民宅 岘港的海滩 在岘港我跟几个在sleeping bus上认识小伙伴一起租摩托车并在傍晚出发去了会安。 下面几张是在会安夜市上拍的。 仔细看的话，可以发现有很多壁虎 花110k买了一整个榴莲，吃到饱 在去往山茶半岛的路上拍的海景。 不过山茶半岛没去成。。租的摩托太坑了，一上坡就特么熄火。。推着翻过几个坡之后累的我蛋疼，干脆回去了。
离开前体验了下本地人消遣的方式之一。。 感觉在岘港留下了不少遗憾，玩的不是很尽兴，希望以后会有机会再弥补吧。不过在岘港认识了来自上海的岘港通Jimmy帅哥，帮了我很多忙，这里也祝他创业顺利啦！还有超级老司机Michael，祝他。。约到性价比更高的妹子？</description></item><item><title>暑假越南行（一）</title><link>https://www.takuzen.me/posts/2016-08-29-summer-trip-to-vietnam/</link><pubDate>Mon, 29 Aug 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-08-29-summer-trip-to-vietnam/</guid><description>【2016.8.25 已更新完在越南境内的第三天】 需要看攻略的童鞋请直接跳至经验篇。
准备阶段 2016.6.3 开始写此文。之前的几个月办下了护照，看了些攻略。
路线计划： 我只是在脑子里想了想大概的路线，因为打算自由一点，走一步算一步（其实是实在没耐心做详细的规划）。 河内 顺化 岘港 会安 芽庄 大叻 美奈 胡志明 从长沙出发到南宁，做大巴出关。
待办： 签证 保险 买背包、一双徒步鞋
出发啦 2016.7.31 南宁 出发去南宁~在瓦舍订了一晚，听说是很棒的青旅。到了之后发现位置不是很好，但是里面的环境还不错。（忘了拍照） 在夜市上吃到的一碗不知叫什么的粉 2016.8.1 南宁-河内 早上到车站，准备坐大巴出发 越南那一侧的边检，在我们这边时没敢拍照。。
话说我们的兵哥哥真不是盖的，无论是气势，纪律还是外观，比越南简直强太多了。。
从口岸去河内的路上 在离河内大概还有20多公里的时候，我们的大巴竟然 __爆胎了！！！__左后轮并列的两个胎全爆 倾斜的大巴，这要是爆的前胎的话，简直不敢想会有什么后果 兵哥哥过来查看，丑爆的交警制服。。 终于到了市里~ 在河内三十六行街吃到了人生中第一碗河粉。好吃到爆！ 当晚的青旅，就在三十六行街 还剑湖夜景 湖边卖艺的欧洲帅哥 ๑乛◡乛๑ 2016.8.2 河内 属于河内的一天
巴亭广场&amp;amp;胡志明纪念堂 高地咖啡店里头点的法棍 下午又遇到了在大巴上认识的大叔，超级超级nice的人，拉着我去他酒店歇脚，又拿饮料又泡茶，临走还多次嘱托我一个人要注意安全。合影就不贴上来了（//▽//）
晚上坐上了去岘港（实际是去顺化）的sleeping bus，是（在国内）比较出名的新咖啡。一天算是结束啦 感想：河内街头的摩的 不能坐 ，无论他们怎样跟你打感情牌；掏钱的时候要注意数清楚有几个零；去便利店买酸奶喝，有个妹子跟我聊的很开心，老板娘也很善意，这在人人都想宰你一笔的河内来说真的好难得。。</description></item><item><title>hexo迁移心得</title><link>https://www.takuzen.me/posts/2016-08-26-hexo/</link><pubDate>Fri, 26 Aug 2016 18:44:24 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-08-26-hexo/</guid><description>经过一番折腾，把博客从Jekyll迁移到了Hexo。不得不说Hexo的体验真的不错。有很多jekyll没有的特性。
skip_render 博客建立完之后想提交readme，结果放在source文件夹下的readme.md总是会被渲染成html。后来发现在根目录的__config.yml里有skip_render这个参数，用来定义不进行解析的文件。
skip_render: readme.md 生成sitemap 先安装：
npm install hexo-generator-sitemap --save 然后再根目录的_config.yml里设置：
sitemap: path: sitemap.xml 多终端同步 平时kubuntu+windows经常切换，两个系统上都有写字的需要。hexo使用自带的d命令部署，提交到github上的是解析之后的文件。网上参考了几种方法，感觉都不太满意。最后我决定创建额外的分支来提交源文件。
git checkout -b src git add . git commit -m &amp;quot;source branch&amp;quot; git push origin src 根据自己的需要修改.gitignore文件。 在另外的终端下直接clone仓库进行部署就好。然后平时直接在src分支下工作，使用hexo d -g会直接发布到master分支，源文件就通过正常的提交方式提交，两者互不冲突。 当然，写新文字前记着git pull把另外一台机器之前提交的内容更新下来。</description></item><item><title>About me</title><link>https://www.takuzen.me/about/</link><pubDate>Wed, 24 Aug 2016 17:51:42 +0000</pubDate><guid>https://www.takuzen.me/about/</guid><description>Github: monkeyWzr
Email: monkeywzr@gmail.com
--</description></item><item><title>ioc要点简记</title><link>https://www.takuzen.me/posts/2016-08-24-ioc-notes/</link><pubDate>Wed, 24 Aug 2016 01:50:45 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-08-24-ioc-notes/</guid><description>文中资料出处： 浅谈IOC&amp;ndash;说清楚IOC是什么 浅谈 Laravel 设计模式 深度理解依赖注入
IOC的含义 IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。
面向对象设计及编程的基本思想简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。
在面向对象设计的软件系统中，它的底层都是由N个对象构成的，各个对象之间通过相互合作，最终实现系统地业务逻辑。 伴随着应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。
IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。 由图可以看出，系统增加了在中间位置的第三方。此时构成系统的各个部分并没有耦合关系，而是是借助这个第三方来互相粘合。这个第三方也就是IOC容器的作用。在容器的穿针引线下，系统的各个部分才能结合起来发挥作用。如果图中没有IOC容器这个第三方存在，系统的各个部件彼此毫无联系。也就是说，在实现与变更A的时候，完全不用考虑与其他部件之间的影响。 这也就是IOC（控制反转）这个名字的含义： 软件系统在没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 软件系统在引入IOC容器之后，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
//主动依赖 function __construct() { $this-&amp;gt;user = new UserModel(); } //被动依赖 function __construct(UserModel $user) { $this-&amp;gt;user = $user; } IOC中最基本的技术就是 反射(Reflection) 编程。反射通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。很多框架中都是把“反射”做为最基本的技术手段。
IOC的优缺点 优点 flexibility changing the implementation class for a widely used interface is simpler (e.g. replace a mock web service by the production instance) changing the retrieval strategy for a given class is simpler (e.</description></item><item><title>laravel设计模式</title><link>https://www.takuzen.me/posts/2016-08-20-laravel-design-patterns/</link><pubDate>Sat, 20 Aug 2016 23:29:17 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-08-20-laravel-design-patterns/</guid><description>DI与IOC laravel中实现了DI依赖注入，如：
class UserController { private $user; function __construct(UserModel $user) { $this-&amp;gt;user = $user; } } $user = new UserController(new UserMonel()); UserController依赖UserModel，在实例化时，laravel会自动主注入UserModel实例。</description></item><item><title>composer用法</title><link>https://www.takuzen.me/posts/2016-07-10-composer-usages/</link><pubDate>Sun, 10 Jul 2016 12:21:46 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-07-10-composer-usages/</guid><description>composer.json 要开始在你的项目中使用 Composer，你只需要一个composer.json文件。该文件包含了项目的依赖和其它的一些元数据。
首先需要指定require key的值
{ &amp;quot;require&amp;quot;: { &amp;quot;monolog/monolog&amp;quot;: &amp;quot;1.0.*&amp;quot; } &amp;quot;require-dev&amp;quot;: { &amp;quot;phpunit/phpunit&amp;quot;: &amp;quot;4.8.*&amp;quot; } } require属性列出组件依赖的组件，require-dev属性列出的是开发时所需依赖，在生产环境下不会安装。
包名 包名应该包含供应商名和项目名
包版本 指定版本号 1.0.2，1.0.0-dev，1.0.0-alpha3 范围 &amp;gt;=1.0 &amp;gt;=1.0,&amp;lt;2.0 &amp;gt;=1.0,&amp;lt;1.1|&amp;gt;=1.2 ,的优先级高于| 通配符 1.0.* 赋值运算符 ~1.2 相当于&amp;gt;=1.2,&amp;lt;2.0 允许依赖不稳定包 @beta @dev 形如1.0.*@beta，或者dev-master#2eb0c0978d290a1c45346a1955188929cb4e5db7这种明确了版本号的也是支持的。
波浪号运算符的意义在于，防止大版本更新而产生的兼容性问题。
Dist dist 指向一个存档，该存档是对一个资源包的某个版本的数据进行的打包。通常是已经发行的稳定版本。
Source source 指向一个开发中的源。这通常是一个源代码仓库，例如git。当你想要对下载下来的资源包进行修改时，可以这样获取。
你可以使用其中任意一个，或者同时使用。这取决于其它的一些因素，比如user-supplied 选项和包的稳定性，前者将会被优先考虑。
repositories 默认情况下 composer 只使用 packagist 作为包的资源库。通过指定资源库，你可以从其他地方获取资源包。
Repositories 并不是递归调用的，只能在Root包的 composer.json 中定义。附属包中的 composer.json 将被忽略。
支持一下类型的资源库：
composer: 一个 composer 类型的资源库，是一个简单的网络服务器（HTTP、FTP、SSH）上的 packages.json 文件，它包含一个 composer.json 对象的列表，有额外的 dist 和/或 source 信息。这个 packages.</description></item><item><title>git日常使用心得</title><link>https://www.takuzen.me/posts/2016-07-05-git-notes/</link><pubDate>Tue, 05 Jul 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-07-05-git-notes/</guid><description>As with many great things in life, Git began with a bit of creative destruction and fiery controversy.
版本控制 版本控制系统(VCS)是一套方便开发团队管理项目的工具。它可以追踪代码的每一次改动，并保存到特殊的数据库中。开发者可以轻松的将项目回滚到历史上的某一个版本上去。
分布式(Distributed)版本控制 是什么概念呢。在DVCS中，没有严格意义上的中央server，每一台用户终端都可以充当中央仓库的角色。因为用户终端并不是checkout了项目的快照，而是镜像了整个仓库。用户终端的仓库也可以互相推送自己的更新。
GIT的玄学哲学 Snapshots, Not Differences Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。这种形式也为git超强的分支管理打下了基础。
Nearly Every Operation Is Local 本地仓库包含了完整的项目历史，所以不需要经常通过网络读取数据。
If you’re used to a CVCS where most operations have that network latency overhead, this aspect of Git will make you think that the gods of speed have blessed Git with unworldly powers.</description></item><item><title>jquery实现表单上传图片预览</title><link>https://www.takuzen.me/posts/2016-06-03-form-image-preview/</link><pubDate>Fri, 03 Jun 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-06-03-form-image-preview/</guid><description>最近有个小页面需要实现图片上传预览，自己还不擅长javascript，迷茫的看了好久文档之后算是利用File API实现了这个事情。 js代码：
&amp;lt;script&amp;gt; function preview(files){ for (var i = 0; i &amp;lt; files.length; i++) { var file = files[i]; var reader = new FileReader(); reader.onload = (function(aImg) { return function(e) { //假设页面上的img元素id为showimg $('#showimg') . attr('src', e.target.result); }; })(); reader.readAsDataURL(file); } } &amp;lt;/script&amp;gt; 调用只要在input元素上加上onchange=&amp;quot;preview(this.files)&amp;quot;。
相关链接 在web应用中使用文件 &amp;ndash; Mozilla 文档 来自百度的一个上传组件http://fex.baidu.com/webuploader/</description></item><item><title>kali2016下phpredis的使用</title><link>https://www.takuzen.me/posts/2016-05-17-phpredis/</link><pubDate>Tue, 17 May 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-05-17-phpredis/</guid><description>phpredis安装 安装phpredis非常的简单，github上文档写的很详细。 在源码根目录执行：
phpize ./configure [--enable-redis-igbinary] sudo make &amp;amp;&amp;amp; sudo make install 对于没有安装phpize的情况，可以apt-get安装dev包
sudo apt-get install php5-dev 如果用的是php7，记得要使用php7分支，或者终端下载：
git clone -b php7 https://github.com/phpredis/phpredis.git</description></item><item><title>简记oath2.0</title><link>https://www.takuzen.me/posts/2016-04-22-understanding-oauth2/</link><pubDate>Fri, 22 Apr 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-04-22-understanding-oauth2/</guid><description>简介 OAuth2就是第三方应用获取授权的一套开放网络标准。它在客户端和服务端提供了一层中间授权层，客户端提供登录信息给授权层，登录成功后会拿到一张自己的通行令牌（token），客户端凭借此令牌别可以得到相行的服务端访问权限。
授权流程 客户端向用户提示授权 用户同意授权，向客户端提供授权许可（grant） 客户端向认证服务器发送认证请求，请求中包含用户提供的授权许可 认证成功后认证服务器向客户端发放令牌（token） 客户端使用令牌向服务器端请求资源 资源服务器验证令牌有效，答复请求 授权许可方式 在用户向客户端提供授权许可这一环节，OAuth2定义了四种类型：授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）、客户端模式（client credentials）。
授权码（authorization code） 这种模式中，客户端将用户引导到授权服务器上，用户同意授权后授权服务器将会令用户重定向至客户端指定的回调地址，并带有授权码。客户端收到授权码后便会自行请求认证服务器，认证服务器核对无误即会返回给客户端访问令牌和更新令牌。整个流程中用户实际上只是跟认证服务器提交了认证，并未与客户端分享任何登录信息。
简化模式（implicit） （懒得简化了，先贴出来放在这=。=） The implicit grant is a simplified authorization code flow optimized for clients implemented in a browser using a scripting language such as JavaScript. In the implicit flow, instead of issuing the client an authorization code, the client is issued an access token directly (as the result of the resource owner authorization).</description></item><item><title>php几种设计模式</title><link>https://www.takuzen.me/posts/2016-04-18-php-design-pattern/</link><pubDate>Mon, 18 Apr 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-04-18-php-design-pattern/</guid><description>php设计模式 单例模式 多例模式 代理模式 代理模式实际上就是解决了在有些不适合继承的情况下使用方法的问题。在proxy类中实现__call()方法调用被代理类的方法。
外观模式（facade） 装饰者模式(decorator) 工厂模式 观察者模式 发布者/订阅者模式</description></item><item><title>docker基础简记</title><link>https://www.takuzen.me/posts/2016-03-09-docker-guide/</link><pubDate>Wed, 09 Mar 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-03-09-docker-guide/</guid><description>Docker是什么 Docker allows you to package an application with all of its dependencies into a standardized unit for software development. &amp;mdash;-What is Docker?
Docker是近几年兴起的发展非常快速的开源项目，可用来创建非常轻量的“虚拟机”。在这里重要的两个概念是 镜像 和 容器 。
docker命令简记 run 启动 -t 在容器内指定一个终端 -i 允许对容器内的STDIN进行交互 -d 在容器内已后台进程模式运行 -P 将容器内部使用的网络端口随机映射到主机高端口上 -p 指定要绑定的端口，具体用法见文档 -e KEY=value 设置环境变量 &amp;ndash;name container_name 为容器命名 &amp;ndash;rm 创建临时容器，停止后删除 ps 查看正在运行的容器 -l 显示最后启动容器的详细信息 -a 显示所有容器，包括已经停止的 logs container_name 查看容器内的标准输出 -f 保持活动状态，动态显示新添加的信息 stop 停止正在工作的容器 version 返回Docker 客户端和进程的版本信息 port container_name top 查看容器内部运行的进程 inspect 查看容器的底层信息（配置和状态），JSON格式 -f &amp;lsquo;{{ obj.</description></item><item><title>基本的bash shell命令</title><link>https://www.takuzen.me/posts/2016-03-05-bash-shell/</link><pubDate>Sat, 05 Mar 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-03-05-bash-shell/</guid><description>基本的bash shell命令 处理文件和目录 ls 输出目录 -s 显示文件大小 -a 输出隐藏文件 -i 显示文件的索引值 -l 产生长列表的输出 -R 递归列出子目录内容 touch 创建新文件或者改变访问/修改时间 -a 只改变访问时间 -m 只改变修改时间 -t 指定时间戳 cp 复制文件 -f 强制覆盖不提示 -i 覆盖前提示 -r 递归的复制文件 -R 递归的复制目录 -l 创建文件链接（硬链接） -s 创建符号链接（软连接） -v 详细模式 mv 移动文件（重命名） rm 删除文件 -i 删除前提示 -f 强制删除不提示 -r 递归删除非空目录 mkdir 创建目录 stat 提供文件的所有状态信息 file 查看文件类型 cat 显示文本数据 -n 给所有行加上行号 -b 给有文本的行加上行号 -s 多个空白行压缩为一行 -T 用^I替换制表符 more 分页显示 空格 显示下一屏 ENTER 显示下一行 /expression 查找 n 查找下一处匹配的内容 ' 调到匹配的第一处内容 !</description></item><item><title>超老本子CF-W2安装lubuntu</title><link>https://www.takuzen.me/posts/2016-03-04-refresh-old-laptop/</link><pubDate>Fri, 04 Mar 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-03-04-refresh-old-laptop/</guid><description>祭出大杀器CF-W2 前几年亲戚去日本出差给我老爸带回来一台二手本本，2003年左右的机器，质量确实过硬，没换过一个零件。。奔腾M 1GHz + 760MB内存，用xp勉强可以看个新闻玩玩同城游戏。到我手里后，实在是食之无味弃之可惜，索性装个linux敲代码好了。
老机器真蛋疼 轻量级的linux有不少，lubuntu xubuntu PuppyLinux这些都是很常见的了。lubuntu号称256M内存就能跑起来，LXDE也比puppy用的JVM好看一点（私人观点），那就先搞这个试试（15.04）。最开始做了个U盘启动盘，结果BIOS里死活读不出usb，只好又刻了个CD。 lubuntu在12.04开始需要cpu支持pae，幸运的是我这老古董貌似完全不支持，因此在进入到grub后光标移动到install lubuntu选项，F6然后esc，进入编辑，在最后面加入forcepae,最后大概是下面这样的：
Boot Options file=/cdrom/preseed/ubuntu.seed boot=casper initrd=/casper/initrd.lz quiet splash -- forcepae 这么改完后可以正常启动安装。安装过程语言最好选择English，不然后面会出现乱码，完全辨认不出选项。
优化 显卡问题 除了开机有（chao）些（ji）慢，编译有（shi）些（fen）慢，总体上还是非常流畅的。不过每次开机后桌面壁纸会变成一坨颜色。在官方wiki上找到了应对老Intel显卡的处理办法。
sudo vim /etc/X11/xorg.conf 添加如下语句：
Section &amp;quot;Device&amp;quot; Identifier &amp;quot;Intel Graphics&amp;quot; Driver &amp;quot;intel&amp;quot; Option &amp;quot;AccelMethod&amp;quot; &amp;quot;uxa&amp;quot; EndSection 重启X，问题解决。
中文乱码 安装过程中如果选择中文会出现乱码，安装好之后的系统人类基本无法操作。不过update完了之后问题即可解决。建议用英文安装好，update完事再切换中文。
相关链接 AdvancedMethods</description></item><item><title>Kali的一些工具</title><link>https://www.takuzen.me/posts/2015-12-19-tools-of-kali/</link><pubDate>Sat, 19 Dec 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-12-19-tools-of-kali/</guid><description>信息收集 DNS信息 host 查询/etc/resolv.conf中指定的DNS服务器 dig 可处理文件内的所有DNS指令 dnsenum 可通过google搜素子域名；课使用字典对子域名进行暴力破解； dnsdict6 IPv6子域名枚举 fierce 能对不连续的IP空间和主机名进行测试 DMitry 具有DNS分析和路由分析功能，可进行简单端口探测 Maltego 图形化综合工具 路由信息 tcptraceroute 利用TCP SYN数据包进行路由信息探测 tctrace -i -h 搜索引擎 theharvester 通过多个公共资源搜集所需信息（Email、用户名、主机名等） Metagoofil 通过google搜索目标域的文件的元数据信息，kali2默认貌似没有安装 目标识别 识别主机 ping 老朋友。。 ping6 用来ping IPv6 fping 可同时探测多个主机或者整个网段 arping 使用ARP请求检测局域网内主机是否在线，IP或者MAC地址都可作为目标 hping3 端口扫描、防火墙规则检测、IDS检测等，功能强大 nping 支持多种协议探测模式；可做压力测试、ARP中毒、Dos攻击 nbtscan 审计局域网内windows系统IP地址、NetBIOS信息等 识别操作系统 p0f 被动方式探测目标主机 nmap 神器之一 服务枚举 端口扫描 nmap 端口扫描；主机探测；服务/版本检测；操作系统检测；网络路由跟踪；脚本引擎 -sT TCP连接扫描 -sS SYN扫描（半开连接扫描） -sN NULL扫描（不设置任何控制位） -sF FIN扫描 -sM TCP Maimom扫描，常用于探测BSD衍生出来的操作系统 -sA TCP ACK扫描，能检测防火墙，确定定被屏蔽端口 -sW TCP窗口扫描 -sI 通过僵尸主机发动扫描 &amp;ndash;scanflags 自定义URG、ACK、PSH、RST、SYN、FIN、ECE、CWR、ALL和NONE组合 -sU UDP扫描 -sV 服务版识别 -O 识别操作系统 -p 指定端口或端口范围 -F 快速扫描，近扫描常用100个端口 -r 顺序扫描 -oN 正常输出 -oX 将结果生成为XML文件 -A 强力扫描，相当于 -sV -O -sC &amp;ndash;traceroute -sC 使用默认类的脚本进行扫描 相当于&amp;ndash;script=default &amp;ndash;script 根据指定文件名、类别名、目录名执行相应脚本 -f 使用小数据包，避免目标IDS识别 &amp;ndash;mtu 调整数据包大小，必须是8的倍数 -D 在侦测数据包中掺杂一些假源IP的数据包。 -g 模拟源端口 &amp;ndash;data-length 改变数据包默认长度 &amp;ndash;scan-delay 控制发送探测数据的时间间隔 Unicornscna 扫描UDP端口性能卓越 zenmap nmap的图形化扫描工具 amap 检测指定端口上运行的应用程序信息 SNMP枚举 SNMP 简单网络管理协议，运行于161端口的应用层协议，用于网络设备运行状态的监控， SNMP协议有三个版本v1/v2/v3</description></item><item><title>Kali下Metasploit学习笔记</title><link>https://www.takuzen.me/posts/2015-12-07-metasploit-on-kali/</link><pubDate>Mon, 07 Dec 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-12-07-metasploit-on-kali/</guid><description>启动 使用框架前先开启其几个服务：
# service postgresql start # msfdb init 注意kali2.0开始不再有metasploit服务，所以官方文档说要用msfdb init代替service metasploit start
然后启动msf控制台
# msfconsole 一些命令 workspace -h 帮助 workspace [-a/d/r] 创建/删除/重命名工作平台</description></item><item><title>Linux下curl实现某资源站自动签到脚本</title><link>https://www.takuzen.me/posts/2015-12-06-curl-on-linux-for-autoregistering/</link><pubDate>Sun, 06 Dec 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-12-06-curl-on-linux-for-autoregistering/</guid><description>前言 经常去某资源站下载美剧，我很喜欢的的团(ren)队(ren)在运营这个网站，资源很及时也很好。网站要求登录才能看到下载链接。连续登录达到多少天就可以升级并且可以查看更多下载资源。然而我这种人是不可能记着每天都去网站上签到的(-&amp;lt;-)。。。正好最近买了vps，于是决定自己写一个自动登录的脚本。
分析 Fiddler抓包发现此网站登陆时url为/User/Login/ajaxLogin，post提交用户名和密码。
登录成功之后返回JSON字符串
用户等级等相关信息是通过之后的两个请求hotkeyword``getCurUserTopInfo获取的，用于网站顶部的信息和搜索栏。
通过我的测试发现这两个请求并不会影响cookie的变化，不模拟也完全没问题。
签到页面url为/user/sign,签到按钮通过js控制15s后才可以点击，点击后fiddler抓到了/user/sign/dosign的请求，request包里面看起并没有什么新内容，response返回了一个json
json里面的info表示签到结果，1为成功。data为连续签到天数。
开搞 OK！开始祭出杀气__curl__，一开始是用的php，但是向dosign发送请求总是返回错误状态，可能是那里的curl参数配置错了，找个时间再回过头去看一下。。就不说这个了。
后来决定干脆直接上linux写脚本。我水平比较low。。就是简单的3个请求，存一下cookie，也没搞啥复杂东西。
先简单在本地测试了一下
哈哈，大功告成！！
最后把脚本丢到了vps上跑，crontab添加一条定时任务，每天凌晨啪啪啪~~ 麻麻再也不用担心我的签到~~</description></item><item><title>vi/vim命令简记</title><link>https://www.takuzen.me/posts/2015-12-05-vim-guide/</link><pubDate>Sat, 05 Dec 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-12-05-vim-guide/</guid><description>模式 vi有三种模式
命令模式 插入模式 扩展模式 命令模式下的操作 移动光标 h,j,k,l 左下上右 w/d 上一个字符/下一个字符 (/) 上一个句子/下一个句子 {/} 上一个段落/下一个段落 修改 cc/cw/cl 重写行/词/字符 dd/dw/dl 删除行/词/字符 yy/yw/yl 复制行/词/字符 dtc，删除从光标到c之间的所有字符 rc，将光标下的字符替换为c 5dd，删除5行数据 5yy，复制5行数据 5x，删除5个字符 p/P 粘贴复制修改或者删除的数据，p粘贴在行上，P粘贴在行下 撤销和恢复 u 撤销最近一次修改 ctrl+r 撤销最近一次撤销 U 撤销所有修改 搜索 /text 向后搜索 ?text 向前搜索 n 搜索下一个同样的的内容 N 搜索上一个同样内容 R，进入替换状态，esc退出 读取，保存与退出 读取保存退出这些操作都是在扩展模式下操作。
:w 保存 :w! 强制保存 :q 退出 :q! 强制退出 :wq 保存退出 :wq! 强制保存退出 :r filename 将另一个文件读入到当前文件内光标所在位置后 :1,20 w filename 将1-20行写入新文件中 :29,$ w filename 将第20行至最后一行写入新文件 :1,20 w&amp;raquo;filename 将第1值20行追加到另一个文件中 定位 G 跳转到文件最后一行 1G 跳转到文件的第一行 ctrl-d 往下滚动半屏 ctrl+u 往上滚动半屏 H 跳转到本屏显示的第一行 M 调转到本屏显示的中间一行 L 跳转到本屏显示的最后一行 z+Enter 使当前的行成为屏幕显示的第一行 z- 使当前行成为屏幕的最后一行 查找与替换 使用sed进行查找和替换 sed是linux下一个很常用的工具。在扩展模式下输入s即可使用sed进行替换。</description></item><item><title>vps搭建私人pptp vpn,新姿势GET！</title><link>https://www.takuzen.me/posts/2015-12-01-my-personal-pptp-vpn-on-vps/</link><pubDate>Tue, 01 Dec 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-12-01-my-personal-pptp-vpn-on-vps/</guid><description>一直用hosts和goagent的姿势搞学(ke)术(xue)研(shang)究(wang)，苦于两种方式限制颇多不稳定又不安全。不久前咬牙花了5刀开了DO的vps（当然，DO赠送了10刀回来），穷学生一枚的我终于能换换新姿势了，直接动手搭建了vpn。由于本人不太喜欢用额外的客户端，再加上pptp以简单著称，我决定采用pptp server。
DigitalOcean购买VPS 在网上查了大家的经验攻略，自己看了下DO、搬瓦工、bugdetVM，最后还是选了DO，反正现在感觉速度很不错，挺满意的。
这个流程很简单，在官网上注册账号，用PayPal下个5刀的订单，DO会赠送10美元回来。Paypal支持银联的卡，我就是用建行的借记卡支付的。支付完成后按照流程创建Droplet，我用的ubuntu14.04 x64,旧金山的服务器，创建过程中添加SSH,用puttyputtygen即可。具体内容在下面相关链接。
安装pptp和配置 putty登陆，速度可以，直接开始安装。这期间我试了试DO网站上的console，感觉不好用。还是putty方便。
# sudo apt-get update # sudo apt-get install pptpd 事实证明我朝GFW有多坑，服务器在美国的ubuntu从官方源下载速度炒鸡快，瞬间完事儿。
修改pptp配置 修改/etc/pptpd.cong文件
# sudo nano /etc/pptpd.conf 在末尾添加server IP 和 client IP
localip 192.168.0.1 remoteip 192.168.0.100-200 这里用的是nano编辑器，不熟悉的同学（比如我）可以参见相关链接里面的“Linux下的Nano命令”。其实用不到啥。。就是一个保存和退出而已。。nano还是比较简单的。
修改DNS配置 # sudo nano /etc/ppp/pptpd-options 添加google的DNS
ms-dns 8.8.8.8 ms-dns 8.8.4.4 这个文件里还开启了其他的一些选项，课根据需要开启我从别的大神那里复制来了一些资料：
name pptpd（pptpd服务名，可以随便填写。） refuse-pap（拒绝pap身份认证模式。） refuse-chap（拒绝chap身份认证模式。） refuse-mschap（拒绝mschap身份认证模式。） require-mschap-v2（在端点进行连接握手时需要使用微软的 mschap-v2 进行自身验证。） require-mppe-128（MPPE 模块使用 128 位加密。） ms-dns 8.8.8.8 (ppp 为 Windows 客户端提供 DNS 服务器 IP 地址。) proxyarp (建立 ARP 代理键值。) nodefaultroute（不替换默认路由） debug（开启调试模式，相关信息记录在 /var/logs/message 中。现在默认是被注释掉的。） lock（锁定客户端 PTY 设备文件。） nobsdcomp (禁用 BSD 压缩模式。)</description></item><item><title>C#学习笔记</title><link>https://www.takuzen.me/posts/2015-10-31-c-sharp-notes/</link><pubDate>Sat, 31 Oct 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-10-31-c-sharp-notes/</guid><description>这里记录的都是与c/c++不太一样的地方，
数据类型 值类型 从类System.ValueType中派生，比较独特的有decimal``sbyte; C#提供了内置类型转换的方法，例如ToBoolean``ToInt32``ToString等等。
可空类型(Nullable) 这个单独列出来了因为很有趣，他是允许值为正常类型范围内或者是null。
//语法 &amp;lt;date_type&amp;gt; ? &amp;lt;variable_name&amp;gt; = null; int? num1 = null; int? num2 = 250; Null合并运算符??用于定义可空类型和引用类型的默认值；如果第一个操作数的侍卫null则返回第二个操作数，否则返回第一个操作数的值。
//继续使用上面的num1和num2 int num3; num3 = num1 ?? 10;//num3 = 10; num3 = num2 ?? 38;//num3 = 250; 引用类型 引用类型不包含储存在变量中的实际数据。内置的引用类型有object``dynamic``string
对象(object)类型 object类型是c#通用类型系统CTS中所有数据的终极基类，可以分配任何类型的值。一个值类型转换为对象类型时称为__装箱__，反过来称为__拆箱__;
object obj； obj = 100;//装箱 动态(Dynamic)类型 类型检查在运行时发生。
dynamic a = 20; 字符串(String)类型 String是System.String类的别名，从对象类派生。有一个@分配方式（称作逐字字符串）。</description></item><item><title>快速临时解决phpmyadmin上传sql文件大小限制问题</title><link>https://www.takuzen.me/posts/2015-10-29-phpmyadmin-upload-filesize-limit/</link><pubDate>Thu, 29 Oct 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-10-29-phpmyadmin-upload-filesize-limit/</guid><description>刚刚需要往服务器上导入数据库，服务器上的phpmyadmin有上传限制，最大是8192kb，我要导入的数据库压缩完了还有8300多。。不想对服务器配置做啥改动，不能远程登录mysql,脚本也不太好跑。查了一下原来phpmyadmin的上传限制是受php.ini和自己的config控制的，mysql控制台并不受影响。干脆直接从命令行导入好了。
mysql&amp;gt;use test; mysql&amp;gt;set names utf8; mysql&amp;gt;source D:/fuck.sql;</description></item><item><title>开机流程中的事儿</title><link>https://www.takuzen.me/posts/2015-10-24-about-booting/</link><pubDate>Sat, 24 Oct 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-10-24-about-booting/</guid><description>一些基本概念 MBR分区表 MBR - Master Boot Record 主引导记录/主引导扇区
MBR分区方案中硬盘的每个扇区通过32位二进制数逻辑块地址（LBA）来标识。计算机开机后访问硬盘时要先读取第一个扇区，这个扇区（通常有512bytes）储存着主引导记录MBR（446bytes）和分区表DPT（64bytes）。主引导记录中装有开机管理程序（boot loader），分区表中记录了磁盘分区情况。由于每一条分区记录需要16个字节，因此MBR分区结构只能支持4个主分区，想得到4个以上的分区需要采用扩展分区，注意扩展分区只能有一个，在windows系统中默认划分一个主分区给系统，其余的全部划入扩展分区。扩展分区可以划分出多个逻辑分区。 MBR的局限性在于，分区表大小固定，只能支持4个主分区，而且最大只能支持到2.2TB的分区容量。随着硬盘技术的发展，MBR分区方案有些撑不住了，再加上win8/8.1的催化，GPT分区表逐渐成为主流。
GPT分区表 GPT - GUID Partition Table 全局唯一标识分区表
有些硬盘厂商注意到了MBR分区方案的容量局限，就把容量较大的产品升级到了4KB的扇区，这样使得MBR可以支持最大到16TB,但同时带来了关于在有较大的块的设备从BIOS启动时，如何最佳的划分分区。GPT分区方案中LBA是64位2进制数，因此对于扇区为512bytes的硬盘，容量可以达到9.4ZB。。。 GPT表的最开头，有一块类似MBR的表头，称为PMBR，存有引导程序和一个特殊标识用来表示次硬盘使用GPT分区方式。接下来的LBA1是GPT的分区表头，记录了硬盘的可用空间和分区表项的大小和数目，还有备份分割的位置。GPT有34个LBA区块记录，从LBA2到LBA33每个区块都可以记录4条分区记录，每条记录都达到128bytes。
在一些MBR/GPT混合硬盘中，不同系统实现有些不一致，windows系统通常优先使用MBR。 再来一张windows的分区类型GUID 相关链接 4K对齐
BIOS BIOS - Basic Input/Output System 基本输入输出系统
BIOS是一种业界标准的固件接口，用于开机自检以及加载引导程序。BIOSB其实就是一个16位汇编代码，寄存器参数调用方式，静态链接，以及1MB以下内存固定编址形式的程序。现在的BIOS储存在主板上的只读储存器（EEPROM）或者是闪存（flash）中，可以更新也不怕断电了。
CMOS CMOS - Complementary Metal Oxide Semiconductor 互补金属氧化物半导体 (-.-)
在计算机领域，CMOS就是一块重要的随机储存器（RAM），BIOS的所有信息都存在这里，最怕被抠电池。。
EFI(UEFI) EFI - Extensible Firmware Interface 可扩展固件接口 UEFI - Unified Extensible Firmware Interface 统一可扩展固件接口
UEFI是一种详细描述全新类型接口的标准，是适用于电脑的标准固件接口，旨在代替BIOS。UEFI通过C语言开发，拥有很多BIOS不具备的功能，比如图形化界面、多种多样的操作方式、允许植入硬件驱动程序（.efi）。
相关链接 UEFI官方首页 “暗云”bootkit木马详细技术分析</description></item><item><title>解决jekyll server无法启动问题</title><link>https://www.takuzen.me/posts/2015-10-15-jekyll-server-failed/</link><pubDate>Thu, 15 Oct 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-10-15-jekyll-server-failed/</guid><description>前几天想要post新博客，照旧在本地测试效果，结果忽然发现jekyll server启动不了了 目测是端口被占用，但是啥玩意会占用4000端口呢。。。netstat了下 3608号进程在占用，继续查这个3608进程。。 我勒个草，竟然是个福昕的保护程序。。没啥话可说了，现在就是在抉择是杀掉这个进程还是换个jekyll serve端口(&amp;gt;=&amp;lt;)先把这篇提交了再说
$ jekyll serve --port 4001</description></item><item><title>SQL Server更改服务器身份验证模式</title><link>https://www.takuzen.me/posts/2015-10-09-sql-server-change-authentication-mode/</link><pubDate>Fri, 09 Oct 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-10-09-sql-server-change-authentication-mode/</guid><description>使用 SQL Server Management Studio 更改安全身份验证模式 在 SQL Server Management Studio 的对象资源管理器中，右键单击服务器，再单击“属性”。
在“安全性”页上的“服务器身份验证”下，选择新的服务器身份验证模式，再单击“确定”。
在 SQL Server Management Studio 对话框中，单击“确定”以确认需要重新启动 SQL Server。
在对象资源管理器中，右键单击您的服务器，再单击“重新启动”。如果运行有 SQL Server 代理，则也必须重新启动该代理。
启用 sa 登录名 在对象资源管理器中，依次展开“安全性”、“登录名”，右键单击“sa”，再单击“属性”。
在“常规”页上，您可能需要为登录名创建密码并确认该密码。
在“状态”页上的“登录”部分，单击“启用”，然后单击“确定”
使用 Transact-SQL 启用 sa 登录名 在“对象资源管理器”中，连接到 数据库引擎的实例。
在标准菜单栏上，单击“新建查询”。
将以下示例复制并粘贴到查询窗口中，然后单击“执行”。下面的示例启用 sa 登录名并设置一个新密码。
ALTER LOGIN sa ENABLE ; GO ALTER LOGIN sa WITH PASSWORD = '&amp;lt;enterStrongPasswordHere&amp;gt;' ; GO 相关链接 MSDN-管理数据库引擎服务</description></item><item><title>HTML常用头标签</title><link>https://www.takuzen.me/posts/2015-10-08-html-head-tags/</link><pubDate>Thu, 08 Oct 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-10-08-html-head-tags/</guid><description>meta &amp;lt;meta&amp;gt;标签提供了 HTML 文档的元数据(metadate)。元数据不会显示在客户端，而是被浏览器解析。 meta元素通常用于指定网页的描述，关键词，的文件的最后修改，作者，和其他元数据。 元数据可以被使用浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 Web 服务调用。
&amp;lt;meta&amp;gt;标签通常位于&amp;lt;head&amp;gt;区域内,有如下几个属性；
charset-定义文档字符编码，常用值为utf-8 http-equiv-提供了名称/值对中的名称，并指示服务器把名称/值对添加到发送给浏览器的MIME文档头部 name-提供了名称/值对中的名称，通常情况下可自定义对自己和源文档的读者来说富有意义的名称，常用值有keywords``description等 content-定义与http+equiv或name属性相关的元信息，即名称/值对中的值 scheme-定义用于翻译content属性值的格式，html5中已删除此属性
使用http-equiv属性，服务器将把名称/值对添加到发送给浏览器的内容头部，例如：
&amp;lt;meta http-equiv=&amp;quot;charset&amp;quot; content=&amp;quot;iso-8859-1&amp;quot;&amp;gt; &amp;lt;meta http-equiv=&amp;quot;expires&amp;quot; content=&amp;quot;31 Dec 2008&amp;quot;&amp;gt; 浏览器头部就应包含：
content-type: text/html charset:iso-8859-1 expires:31 Dec 2008 所有服务器都至少要发送一个：content-type:text/html，这将告诉浏览器准备接受一个 HTML 文档。
其它实例：
//定义文档关键词，用于搜索引擎 &amp;lt;meta name=&amp;quot;keywords&amp;quot; content=&amp;quot;HTML, CSS, XML, XHTML, JavaScript&amp;quot;&amp;gt; //每30秒刷新页面 &amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;30&amp;quot;&amp;gt; //声明文档使用的字符编码 &amp;lt;meta charset='utf-8'&amp;gt; 还有一种lang属性写法：
//简体中文 &amp;lt;html lang=&amp;quot;zh-cmn-Hans&amp;quot;&amp;gt; //繁体中文 &amp;lt;html lang=&amp;quot;zh-cmn-Hant&amp;quot;&amp;gt; //英文 &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; lang属性的取值应该遵循 BCP 47 - Tags for Identifying Languages</description></item><item><title>jQury基础笔记</title><link>https://www.takuzen.me/posts/2015-10-01-jqury-notes/</link><pubDate>Thu, 01 Oct 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-10-01-jqury-notes/</guid><description>安装 1.从jqury.com下载
2.CDN
Baidu CDN:http://libs.baidu.com/jquery/1.10.2/jquery.min.js 又拍云 CDN:http://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js 新浪 CDN:http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js Google CDN:http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js Microsoft CDN:http://ajax.htmlnetcdn.com/ajax/jQuery/jquery-1.10.2.min.js 语法 基础语法： $(selector).action()
选择器 jquery选择器基于已存在的css选择器
$(this) - 当前元素 $(&amp;quot;p&amp;quot;) - 所有 &amp;lt;p&amp;gt; 元素 $(&amp;quot;p:first&amp;quot;) - 选取第一个&amp;lt;p&amp;gt;元素 $(&amp;quot;p .test&amp;quot;) - 所有 class=&amp;ldquo;test&amp;rdquo; 的 &amp;lt;p&amp;gt; 元素 $(&amp;quot;.test&amp;quot;) - 所有class=&amp;ldquo;test&amp;quot;的元素 $(&amp;quot;#test&amp;quot;) - 所有 id=&amp;ldquo;test&amp;rdquo; 的元素 $(&amp;quot;[href]&amp;quot;) - 带有href属性的元素 $(&amp;quot;ui li:first&amp;quot;) - 选取第一个&amp;lt;ul&amp;gt;的第一个&amp;lt;li&amp;gt;元素 $(&amp;quot;ui li:first-child&amp;quot;) - 选取每个&amp;lt;ul&amp;gt;的第一个&amp;lt;li&amp;gt;元素 $(&amp;quot;a[target!='_blank']&amp;quot;) - 选取所有target属性值不等于&amp;rdquo;_blank&amp;quot;的&amp;lt;a&amp;gt;元素 $(&amp;quot;:button&amp;quot;) - 选取所有type=&amp;ldquo;button&amp;quot;的&amp;lt;input&amp;gt;元素和&amp;lt;button&amp;gt;元素
还有一些自定义的选择器
$(&amp;quot;tr:even&amp;quot;) - 选取奇数位置的&amp;lt;tr&amp;gt;，偶数为:odd $(&amp;quot;tr:nth-child(odd)&amp;quot;) - 相对于元素的父元素而非当前所选择的元素来选取偶数位置 $(&amp;quot;td:contains(monkey)&amp;quot;) - 选择含有&amp;rsquo;monkey&amp;rsquo;的表格单元</description></item><item><title>正则表达式笔记</title><link>https://www.takuzen.me/posts/2015-09-30-regular-expression-notes/</link><pubDate>Wed, 30 Sep 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-09-30-regular-expression-notes/</guid><description>元字符 . 匹配任何单个字符 * 匹配任意长度 + 匹配前面的一个或多个实例 ? 匹配前面的0个或多个实例 [...] 匹配方括号内的任意字符 ^ 匹配字符串开头 $ 匹配字符串末尾 {n,m} 匹配前面的字符出现n到m次 {n,} 匹配前面的字符至少出现三次 修饰符 修饰符位于结束定界符之后，用来改变正则表达式的行为。
i 不区分大小写 /s 忽略转义回车 /U 匹配字符域 [char list] 匹配方括号内的任意字符集，包括空格。此例即匹配c、h、a、r、空格、l、i、s、t中的任一字符 [^char list] 不匹配方括号内的字符，也可用! [a-z] 匹配字符a-z, 还有几个&amp;ndash;忘了叫啥了的&amp;ndash;
\w 相当与[A-Za-z0-9] \s 匹配空白字符，相当与[\t\r\n] \d 匹配数字，[0-9] \b backspace (0x08) (only if in a range specification) 注：大写效果与小写相反 实例1：
//下面两种效果相同 //匹配由字母数字下划线连字符组成，长度在3-15的用户名 //注意连字符需要转义 /^[\w_\-]{3,15}$/ /^[A-Za-z0-9_\-]{3,15}$/ 实例2：
//匹配email地址 //本地部分包含A-Za-z0-9等，不包含括号，#@;等 /^([\w!</description></item><item><title>从教务系统中获取课程表图片</title><link>https://www.takuzen.me/posts/2015-08-29-get-img-from-base64/</link><pubDate>Sat, 29 Aug 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-08-29-get-img-from-base64/</guid><description>教务系统中的课表以图片形式显示，又不知何故不允许另存，禁用右键也无效（教务使用体验极差，这方面倒是做的细心V.V），以前是用chrome开发者工具翻一下resource就能找到图片，拖下来就成。 昨天想再把新学期课表存下来发现不行了，直接拖到电脑上不管用，拖到新标签页里一堆乱码 拖到sublime text里面，直接变成了整齐的编码 网上查一下之后知道图片经base64编码，我拖下来得到的就是编码后的数据，重现的话写个html就行了
&amp;lt;span&amp;gt;&amp;lt;img src=&amp;quot;data:image/jpg;base64,编码后的数据&amp;quot;&amp;gt;&amp;lt;/span&amp;gt; 看出来了吧，上面图里我拖下来的其实是src里的完整格式。 这样就把图片的“文字版”写到html里了，用浏览器访问即可解码出图片，可以随便保存啦。
这种用base64编码之后传输图片的形式还是比较不错，从别人的博客上摘录下“减少了HTTP请求，某些文件可以避免跨域的问题，没有图片更新要重新上传，还要清理缓存的问题”这些优点。但实际上这种方式并不像想象中那样可以节省流量，文件反而增大约35%，所以大图片就不要用这种方法了。</description></item><item><title>markdown语法简记</title><link>https://www.takuzen.me/posts/2015-08-03-markdown-notes/</link><pubDate>Mon, 03 Aug 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-08-03-markdown-notes/</guid><description>0. 反斜杠 反斜杠可以将在markdown中有特殊意义的字符作为正常字符插入。
1. 标题 类Setext形式 =和-的数量随意，效果效果是相同的。
This is H1 ========== This is H2 ---------- 类atx形式 也可以写成前后对称的形式。
# H1 ## H2 ###### H6 注意在#与标题间必须存在至少一个空格或制表符
2. 引用 &amp;gt;在段落前加&amp;gt;进行引用。 在段落前加&amp;gt;进行引用。 在段落前加&amp;gt;进行引用。
&amp;gt;或者每行前加&amp;gt;进行引用。 &amp;gt;或者每行前加&amp;gt;进行引用。 &amp;gt;或者每行前加&amp;gt;进行引用。
效果相同。
在段落或者每句前加&amp;gt;进行引用 在段落或者每行前加&amp;gt;进行引用。 在段落或者每行前加&amp;gt;进行引用。
加上不同数量的&amp;gt;实现嵌套引用。
3. 代码区块 代码区块只需一个制表符或者4个空格：
当你想插入代码区块
只需4个空格或者1个制表符 标记一小段代码可以用反引号`包起来，在本文随处可见效果。
也可用```的形式：
``` 代码区块 ``` 将产生相同效果。但是此种方法并非标准markdown语法，有时可能会解析不正确。 在代码区块中可以方便的插入HTML原始码，Markdown会自动将&amp;lt;``&amp;amp;等转换为HTML实体。
4. 列表 无序列表
* red + green - yellow 三种形式等同。
red green yellow 有序列表</description></item><item><title>SQL字符串转换成时间</title><link>https://www.takuzen.me/posts/2015-11-16-sql-string-to-date/</link><pubDate>Mon, 03 Aug 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-11-16-sql-string-to-date/</guid><description>最近改一个网站，网站的文章顺序总是很奇怪，看代码明明是order by time desc。看了数据库之后发现time列是字符串格式，导致比较的时候2015/11/2会被认为比2015/11/15大。查了一下后将sql语句改为.......order by cast([time] as date) desc 就解决了问题。
SQL Server支持的两个转换函数：
CAST ( expression AS data_type [ ( length ) ] ) CONVERT ( data_type [ ( length ) ] , expression [ , style ] ) 还有几个其他的转换函数，详细内容请见相关链接。
相关链接 date (Transact-SQL) - MSDN - Microsoft CAST 和 CONVERT (Transact-SQL)</description></item><item><title>开张啦开张啦</title><link>https://www.takuzen.me/posts/2015-08-03-blog-open/</link><pubDate>Mon, 03 Aug 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-08-03-blog-open/</guid><description>我的博客正式开张 自从有了博客，走起路来都飘。这难道就是传说中的装B?
借此博客用来记录成长轨迹，分享学习心得，培养所谓人文情操。</description></item><item><title>言えない秘密</title><link>https://www.takuzen.me/posts/1996-06-01-v2ray/</link><pubDate>Sat, 01 Jun 1996 04:11:11 +0000</pubDate><guid>https://www.takuzen.me/posts/1996-06-01-v2ray/</guid><description>下载 PC客户端安装 点这里下载 V2Ray 的 Windows 压缩包。下载并且解压之后我们重点注意下面这三个文件：
v2ray.exe 运行 V2Ray 的程序文件，会有类似于 cmd 控制台的窗口弹出来。 wv2ray.exe 同 v2ray.exe，区别在于wv2ray.exe是后台运行的，不需要在桌面上保持窗口。运行 V2Ray 时从 v2ray.exe 和 wv2ray.exe 中任选一个即可 config.json V2Ray 的配置文件，后面我们对 V2Ray 进行配置其实就是修改这个文件。可以通过记事本或其它的文本编辑器打开查看。 首先把我发给各位的config.json放到上面解压缩好的文件夹内，替换掉原有的config.json文件。 然后双击 wv2ray.exe （或v2ray.exe） 就可以运行 V2Ray 了，V2Ray 会读取 config.json 中的配置与服务器连接。
最后一步我们需要给浏览器设置系统代理。以火狐（Firefox）为例，点菜单 -&amp;gt; 选项 -&amp;gt; 高级 -&amp;gt; 设置 -&amp;gt; 手动代理设置，在 SOCKS Host 填上 127.0.0.1，后面的 Port 填 1080，再勾上使用 SOCKS v5 时代理 DNS (这个勾选项在旧的版本里叫做远程 DNS)。操作图见下：
如果使用的是Chrome，可配合SwitchyOmega插件使用。具体方法后面再说。 如果使用的是其它的浏览器，请自行在网上搜一下怎么设置 SOCKS 代理。</description></item></channel></rss>
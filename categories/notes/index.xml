<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>notes on マクロス</title><link>https://www.takuzen.me/categories/notes/</link><description>Recent content in notes on マクロス</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>呉</copyright><lastBuildDate>Mon, 22 Mar 2021 16:31:57 +0900</lastBuildDate><atom:link href="https://www.takuzen.me/categories/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>プログラミングTypeScriptの読書メモ - 型</title><link>https://www.takuzen.me/posts/programming-typescript-notes-types/</link><pubDate>Mon, 22 Mar 2021 16:31:57 +0900</pubDate><guid>https://www.takuzen.me/posts/programming-typescript-notes-types/</guid><description>難しすぎて、一回3−4ページ文しか進められてない、、
よく自分に聞く：Is this something about TYPEScript(exists only during compile time) or not(to be dealt at runtime)?
聞きながら勉強すると大変助かります。
高度な型 サブタイプとスーパータイプ anyはすべての型のスーパータイプ neverはすべての型のサブタイプ 変性 不変性(invariance) 共変性(covariance) 反変性(contravariance) 双変性(bivariance) ディフォルトでTypescriptの型に関して共変です。 {&amp;quot;strictFunctionTypes&amp;quot;: true}の場合、関数型にはそのパラメータの型が反変にと扱うようにする。具体は下記を参照ください。
関数型の関係と反変 class Animal {} class Bird extends Animal { chirp() {} } class Crow extends Bird { caw() {} } function clone (f: (b:Bird) =&amp;gt; Bird): void { } clone関数は、関数型のパラメータを期待する。(b: Bird) =&amp;gt; Bird型の関数、とそのサブタイプの関数を渡すことができる。 ここまでは普通の共変であり、反変に関係ない。
ではどんな関数は(b: Bird) =&amp;gt; Birdのサブタイプでしょうか
// これをベースとして考えてみる function bToB(b: Bird) : Bird { return new Bird(); }; function bToC(b: Bird) : Crow { return new Crow(); } function bToA(b:Bird) : Animal{ return new Animal() } function aToB(a:Animal) : Bird { return new Bird(); } function cToB(c: Crow) : Bird { return new Bird() } clone(bToB) // OK clone(bToC) // OK clone(bToA) // Error 2345 clone(aToB) // OK clone(cToB) // Error 2345 (b: Bird) : Crowは(b: Bird) =&amp;gt; Birdのサブタイプであり、(b:Bird) : Animalはサブタイプではない。この戻り値の振舞いはまだ共変です。（戻り値はサブタイプの関係　→　関数はサブタイプの関係）</description></item><item><title>JavaのArrays.asListのシグネチャーを始めとしてVarargsとバイトコードを調査した件</title><link>https://www.takuzen.me/posts/java-varargs-and-primitive-types/</link><pubDate>Fri, 29 Jan 2021 23:39:16 +0900</pubDate><guid>https://www.takuzen.me/posts/java-varargs-and-primitive-types/</guid><description>0. 課題 数日前、配列を出力したいので下記のようなコードを書いた
public class Nani { public static void main(String[] args) { int[] nums = new int[]{1, 2, 3, 4}; Arrays.asList(nums).forEach(i -&amp;gt; System.out.println(i + &amp;#34; &amp;#34;)); } } Ideaコード補完の提示に従って書いたし、エラーもないけど実行すると1 2 3 4ではなく、 [I@5ba23b66というようなやつが出力された。オブジェクトとして出力されてることが分かてるけどこれ以上理解できなかった。
友達からヒントをもらって、Integerにすると
Integer[] nums2 = new Integer[]{1, 2, 3, 4}; Arrays.asList(nums2).forEach(i -&amp;gt; System.out.print(i + &amp;#34; &amp;#34;)); 1 2 3 4になった。Listとかジェネリクスとかプリミティブとかに関係あるだろうと思って色々調べてみた。
結局、これらJavaの基本コンセプト:
Varargs Autoboxing Generics はいずれもよく把握してなかった。
ちなみに、Arrays#toStringで簡単に配列が出力できる1
System.out.println(Arrays.toString(array)); // [1, 2, 3, 4] 1. 基本知識の明確 1.1 ジェネリクス「T」にはプリミティブ型が含まれていない. T = T extends Object 後ほどバイトコードを詳細した上、確認できた。</description></item><item><title>思考せずに毎日gettersとsettersを実装している私、その理由が分からない</title><link>https://www.takuzen.me/posts/pretend-to-understand-getters-and-setting/</link><pubDate>Sun, 17 Jan 2021 18:05:32 +0900</pubDate><guid>https://www.takuzen.me/posts/pretend-to-understand-getters-and-setting/</guid><description>最近lombokを使って下記のようなやつを結構実装していた
@Getter @Setter // @Dataもよく使ってる public class Foo { private String name; private int id; } ある日、考えずに動いてる俺は突然目覚めた：上記のような処理せずフィールドの値の参照と設定だけの場合、fieldのアクセス修飾子をpublicにして直接使ったらいいんじゃない？lombokを使ってgettersとsettersを生成する目的は何だっけ？gettersとsettersは何だっけ？
いつからgetters/settersを使うことを習慣になるのか、どこから学んだのか全然覚えてないので、調査してみた。
TL;DR 関係あるキーワード:
Encapsulation, Accessors, Immutable, JavaBeans, POJO, Persistence Ignorance, YAGNI, ORM
Java世界にgetters/setters手法の定番化は、Beanの概念の誕生、発展、およびJavaエコシステムの発展に関係があります。
POJOはライブラリに依存せずごく普通なオブジェクトである、JavaBeanは再利用可能なGUIコンポーネントの定義として登場、現在にいたってBeanの名前で再利用コンポーネントの概念として使われている
調査した後、先頭のような場合なら、publicデータフィルドで扱う方が良いかもしれないじゃないかと思っているが断言できません。 常に考えて、適切な処理を実装するのは大切だと思う。
まず、getters/settersをおすすめしている資料を探した getters/settersはJavaオブジェクト指向プログラミングの入門教材の定番としてよく見られ、カプセルかとかの概念に紐付けられているような印象がある。 だがgoogleしてみるとgetters/settersの必要性を疑ているタイトルがいっぱい出てきた。
おすすめしている資料の一例： Why Should I Write Getters and Setters
後半から
I understand, but generally, we do not write anything in getters/setters. We just return and set the field, which is same as exposing a field as public.</description></item><item><title>Springでjsonリクエスト情報のカスタマイズ処理（変換、バリデーション、共通処理）</title><link>https://www.takuzen.me/posts/spring-handle-request-arguments/</link><pubDate>Mon, 04 Jan 2021 15:13:31 +0900</pubDate><guid>https://www.takuzen.me/posts/spring-handle-request-arguments/</guid><description>内容要補足
共通処理 HandlerInterceptor ControllerAdvice/RestControllerAdvice RequestBodyAdvice @RequestBodyの共通処理に適用。 Filter 不勉強すみません AOP 不勉強againすみません カスタマイズ変換の視点から、下記の方法がある（特に@RequestParamから取得したStringからオブジェクトへのカスタマイズ変換）
RequestBodyAdvice @RequestBodyに適用 ConverterFactory ArgumentResolver @RequestParamとかの制御に適用（カスタマイズ変換） PropertyEditor @RequestParamとかの制御に適用（カスタマイズ変換） HandlerInterceptor インターフェース HandlerInterceptor
リクエストがハンドルされる前後にインタセプトするインタフェースです。（Controllerは当然handlerであると認識しているが、なぜこのインタフェースの名前がControllerIntercepterになってないでしょうか）
インタフェースによりインタセプトタイミングを見ると、Restアプリケーションの場合（特に共通バリデーションとかをしたい場合）に役割が少ないと思った1
preHandle: ハンドラー(controller)メソッドが呼び出される前に呼び出される。httpRequestとhttpResponseがパラメータであるので、一部の前処理とかを実装できる postHandle: ハンドラーメソッドが呼び出された後、DispatcherServlet がビューをレンダリングする前に呼び出される afterCompletion:　ビューのレンダリング後のコールバック 最近のプロジェクトに、preHandleでログ出力の初期設定を行う、afterCompletionでMDCのクリアを行う、のような仕組みを応用した。
ControllerAdvice/RestControllerAdvice Controllerクラスの間に、@ExceptionHandler @InitBinder @ModelAttributeの処理を共通定義できる
Data Binder, Model, Exceptionの共通カスタマイズ処理とかに適用
@ControllerAdvice // @RestControllerAdvice // RestControllerの場合 class SomeCustomControllerAdvice { @InitBinder public void initDataBinder(WebDataBinder dataBinder) { // dataBinder.registerCustomEditorでカスタマイズエディターの登録を行ったり // dataBinder.getTarget()でハンドラーメソッドに渡すPOJOオブジェクトのインスタンスも取得できる } @ModelAttribute public void addSomething(@RequestParam(&amp;#34;someKey&amp;#34;) String someValue, Model model) { // モデルを更新するとか // ハンドラーのようにリクエストパラメータを取得できるので、前処理とか実装できる } @ExceptionHandler // @ExceptionHandler({NullPointerException.</description></item><item><title>プログラミングTypeScriptの読書メモ</title><link>https://www.takuzen.me/posts/programming-typescript-notes/</link><pubDate>Fri, 01 Jan 2021 17:01:34 +0900</pubDate><guid>https://www.takuzen.me/posts/programming-typescript-notes/</guid><description>リテラル let a = 1 // number let c : 3 = 3; // リテラル型 3 const b = 2 // リテラル型 2 const d: number = 4 // number 構造的型付け(structural typing) ダックタイピング
→名前的型付け
インデックスシグネチャ { [key: T]: U } オブジェクトについて 空のオブジェクトリテラル表記{}とオブジェクトプロトタイプ表記Objectはできるだけ避けてください。
let foo: {} foo = 1; foo = {a: 1}; foo = []; foo = &amp;#39;abc&amp;#39;; let bar : Object; bar = 1; bar = {a: 1} bar = [] bar = &amp;#39;abc&amp;#39; foo = {toString() {return 1}} // OK bar = {toString() {return 1}} // Error: Type ‘() =&amp;gt; number’ is not assignable to type ‘() =&amp;gt; string’.</description></item><item><title>Jestでaxiosはネットワークエラーになってしまう件</title><link>https://www.takuzen.me/posts/jest-axios-network-error/</link><pubDate>Wed, 30 Dec 2020 18:02:38 +0900</pubDate><guid>https://www.takuzen.me/posts/jest-axios-network-error/</guid><description>JestでAPIを検証しようとした時、axiosからネットワークエラーが発生した。 背景：localhost:9090のwebpack-server経由でlocalhost:8080のバックサービスを叩く
色々調べると、ランタイム環境に関係ありそう。ちゃんとわかってないけど
解決案１ axiosアダプタをnode環境用のhttpアダプタを使うように変更する1。今回これを使って解決した
import axios from &amp;#39;axios&amp;#39; import httpAdapter from &amp;#39;axios/lib/adapters/http&amp;#39; const instance = axios.create({ adapter: httpAdapter, // ... }); 解決案２ jestのディフォルト環境はブラウザ風のjsdomなので、nodeに変更すればできるはず2
// jest.config.js module.exports = { testEnvironment: &amp;#34;node&amp;#34; }; 又はjest --env=nodeで実行する3
参考 Jestは、axiosで認証されたリクエストを行うと「ネットワークエラー」を返します
configuration#testenvironment-string
Jestでaxiosを使おうとするとNetwork Errorになってうまくいかないときの対処方法
https://stackoverflow.com/a/42678578&amp;#160;&amp;#x21a9;&amp;#xfe0e;
https://www.tolog.site/aws/jest-sam-network-error/&amp;#160;&amp;#x21a9;&amp;#xfe0e;
https://github.com/axios/axios/issues/938&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>WebpackのDefinePluginで環境変数を定義する</title><link>https://www.takuzen.me/posts/webpack-defineplugin/</link><pubDate>Wed, 30 Dec 2020 16:42:34 +0900</pubDate><guid>https://www.takuzen.me/posts/webpack-defineplugin/</guid><description>webpackのDefinePluginでグローバル環境変数が定義できる。
new webpack.DefinePlugin({ // Definitions... }); コンパイル時直接テキスト置換でインラインかされるので、文字列の値を定義したい場合、実際のクォーテーションを含める必要がある1
Note that because the plugin does a direct text replacement, the value given to it must include actual quotes inside of the string itself. Typically, this is done either with alternate quotes, such as &amp;lsquo;&amp;ldquo;production&amp;rdquo;&amp;rsquo;, or by using JSON.stringify(&amp;lsquo;production&amp;rsquo;).
new webpack.DefinePlugin({ PRODUCTION: JSON.stringify(true), // true BROWSER_SUPPORTS_HTML5: true, // true VERSION: JSON.stringify(&amp;#39;5fa3b9&amp;#39;), // &amp;#39;5fa3b9&amp;#39; &amp;#39;SERVICE_URL&amp;#39;: &amp;#39;https://dev.example.com&amp;#39;, // highly possible to recieve a compile error &amp;#39;typeof window&amp;#39;: &amp;#39;&amp;#34;object&amp;#34;&amp;#39;, TWO: &amp;#39;1+1&amp;#39;, // 2 &amp;#39;process.</description></item><item><title>依存性逆転の原則(Dependency Inversion Principle), the D in SOLID</title><link>https://www.takuzen.me/posts/dependency-inversion-principle/</link><pubDate>Sat, 19 Dec 2020 15:43:21 +0900</pubDate><guid>https://www.takuzen.me/posts/dependency-inversion-principle/</guid><description>SOLIDの一つである、依存性逆転の原則(Dependency Inversion Principle, DIP)は一体どういうものか？色々調査してみた。今までもはっきりわかったと言えないがある程度納得したと思う。
まず、依存性の注入(DI)は依存性逆転の原則(DIP)ではない よく言われてる依存性の注入(Dependency Injection, DI)と依存性逆転の原則は、全く別のものである。
あるクラスBの中には、別のクラスAを使う場合、BはAを依存している
class A { public A(int p) { // ... } } class B { public B() { A a = new A(1); // ... } public static void main(String[] args) { B b = new B(); } } DIていうのは、その依存対象を直接扱う代わりに、外から注入することです。
class B { public B(A a) { // ... } public static void main(String[] args) { A a = new A(1); B b = new B(a);　// Bの依存を注入する } } SpringとかのフレームワークはDIを利用して依存関係を管理して注入してくれる。</description></item><item><title>Spring Bean Scope: Singleton and Prototype</title><link>https://www.takuzen.me/posts/spring-bean-scope/</link><pubDate>Sun, 13 Dec 2020 16:36:42 +0900</pubDate><guid>https://www.takuzen.me/posts/spring-bean-scope/</guid><description>シングルトンsingleton Only one instance is created and managed in the Spring container. This instance is shared by all requests so we should use this for stateless beans. Singleton scope is the default scope in Spring.
@Service public class SomeService{ // DANGER! This property is shared by all requests so one user might use others&amp;#39; password private String password; public void authByPassword(){ // ... } } prototype A new instance is created by each request for that bean.</description></item><item><title>N1を目指す</title><link>https://www.takuzen.me/posts/2020-10-15-japanese-notes/</link><pubDate>Thu, 15 Oct 2020 15:43:21 +0900</pubDate><guid>https://www.takuzen.me/posts/2020-10-15-japanese-notes/</guid><description>[]いわば []おまけに []すなわち [x]あるいは []さりとて：＝だが []さりとは： [x]したがって：従って []せざるを得ない：＝しないわけにはいかない、＝しなければならない []にもかかわらず []もしくは：（若しくは）＝あるいは []それゆえ：（それ故）それだから（ちょっと正式の表現） [x]そもそも：抑々 []むしろ：寧ろ。どちらかと言えば
やんわりと 活字離れ（かつじばなれ） 時間を割く「に時間を食われる」 飛ばし読み 偏る 到底（とうてい） じっくり まいった　＝　やられている　打ちのめされてる まだまし おめでたい　＝　皮肉
あいにく持ち合わせなくて
一緒にさせていただいても差し支えありませんか
お中元
からする なればなったで（～ば～で）
ことはない　意地悪な/ひどいことをするような状況じゃない どころではない　～をする時間がない/～をする状況にない わけはない　蛙が空を飛ぶわけはない までではない　ほどのことではない　～という程度までには達してない ほどには当たらない　存在しない文型 までのことではない までにはあたらない
見るともなしに
忍びず　～がもったいなくて はばからず　べくして</description></item><item><title>Changes to String in java (from 1.7.0_06)</title><link>https://www.takuzen.me/posts/2020-06-06-changes-in-java-string/</link><pubDate>Sat, 06 Jun 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-06-06-changes-in-java-string/</guid><description>Before 1.7.0_06, String has 4 non static field:
char[] value int[] offset int count int hash Subing.substring create a String by sharing the original String&amp;rsquo;s internal char[] value and setting offset. This saves memory and makes String.substring run in a constant time($O(1)$). Meanwhile, this feature may cause memory leak1.
http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/8deef18bb749/src/share/classes/java/lang/String.java
public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence { /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used.</description></item><item><title>Algorithms - String Sorts</title><link>https://www.takuzen.me/posts/2020-06-05-string-sorts/</link><pubDate>Fri, 05 Jun 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-06-05-string-sorts/</guid><description>Key-indexed counting Sort an array a[] of N integers between 0 and R-1.
int N = a.length; // the temp array during sorting int[] aux = new int[N]; // the index of count[] is the integer int[] count = new int[R+1]; // count frequencies of N integers // offset by one(a[0] = 0) for (int i = 0; i &amp;lt; N; i++) { count[a[i]+1]++; } // compute frequency cumulates which specify destinations // (how many intgers &amp;lt; the integer r) for (int r = 0; r &amp;lt; R; R++) { count[r+1] += count[r]; } // access cumulates using key as index to move items for (int i = 0; i &amp;lt; N; i++) { aux[count[a[i]]++] = a[i]; } // copy back for (int i = 0; i &amp;lt; N; i++) { a[i] = aux[i]; } Key-indexed counting is stable.</description></item><item><title>Algorithms - Maxflow and Mincut</title><link>https://www.takuzen.me/posts/2020-05-20-maxflow-mincut/</link><pubDate>Wed, 20 May 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-05-20-maxflow-mincut/</guid><description>Model We use a flow network model which is an edge-weighted digraph with positive edge weights referred to as capacities. An st-flow network has two identified vertices, a source s and a sink t.
Minimum Cut problem An st-cut is a partition of the vertices into two disjoint sets, which s in one set A and t in the other set B. Its capacity is the sum of the capacities of the edges from A to B.</description></item><item><title>Algorithms - Graphs</title><link>https://www.takuzen.me/posts/2020-05-01-algorithms-graphs/</link><pubDate>Fri, 01 May 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-05-01-algorithms-graphs/</guid><description>Undirected Graphs Some problems Path Shortest path Cycle Ehler tour: A cycle that uses each edge excatly once. Hamilton tour: A cycle that uses each vertex exactly once classical NP-complete problem. Connectivity MST: Biconnectivity: A vertex whose removal disconnects the graph Planarity Graph isomorphism: Are two graphs identical? No one knows so far. A lonstanding open problem Representations Real-world graphs tend to be sparse (huge number of vertices, small average vertex degree).</description></item><item><title>Racket notes</title><link>https://www.takuzen.me/posts/2020-02-29-racket/</link><pubDate>Sat, 29 Feb 2020 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2020-02-29-racket/</guid><description>Basic #lang racket (provide (all-defined-out)) ;this is a comment (define s &amp;#34;hello&amp;#34;) (define x 3) (define y (+ x 2)) (define cube1 (lambda (x) (* x (* x x)))) (define cube2 (lambda (x) (* x x x))) (define (cube3 x) (* x x x)) (define (pow1 x y) (if (=y 0) 1 (* x (pow1 x (- y 1))))) ; currying (define pow2 (lambda (x) (lambda (y) (pow1 x y)))) List Empty list: null () doesn&amp;quot;t work for null but '() does build a list: (list e1 .</description></item><item><title>Standard ML notes</title><link>https://www.takuzen.me/posts/2019-12-30-standardml-notes/</link><pubDate>Tue, 10 Dec 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-12-30-standardml-notes/</guid><description>Basics Comments (* SML comment *) Variable bindings and Expressions val x = 34; (* static environment: x : int *) (* dynamic environment: x --&amp;gt; 34 *) val y = x + 1; (* Use tilde character instead of minus to reprsent negation *) val z = ~1; (* Integer Division *) val w = y div x Strings:
(* `\n`のようなエスケープシーケンスが利用できる *) val x = &amp;#34;hello\n&amp;#34;; (* 文字列の連結には&amp;#39;^&amp;#39;を使う *) val y = &amp;#34;hello &amp;#34; ^ &amp;#34;world&amp;#34;; An ML program is a sequence of bindings.</description></item><item><title>uipath ノート（三）- uipath orchestrator</title><link>https://www.takuzen.me/posts/2019-11-23-uipath-orchestrator/</link><pubDate>Sat, 23 Nov 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-11-23-uipath-orchestrator/</guid><description>利用手順 Official doc: https://docs.uipath.com/robot/docs/from-orchestrator-and-the-orchestrator-settings-window
マシンを追加 マシン側でマシン名とユーザ名を確認
C:\Users\user&amp;gt;hostname DESKTOP-ABCDE5F C:\Users\user&amp;gt;whoami desktop-abcde5f\user C:\Users\user&amp;gt; 追加完了後、マシンキーを取得する。
ロボットを登録 Type: studio (開発用？) Domain/Username: 上記のユーザ名 ローカルのorchestrator設定 Uipath Robotを開き⇒orchestratorの設定で、上記のマシンキーを入力する。 orchestrator URLに https://platform.uipath.com/ を入力する. Invalid machine keyというエラーが出たら、下記のようなURLを試す：
https://platform.uipath.com/&amp;lt;account name&amp;gt;/&amp;lt;service name&amp;gt; 参照：Uipath orchestrator error : invalid machine key
ロボットグループ(Environment)作成 プロジェクトをパブリッシュ(Publish) プロセスを追加 Automations　⇒　Processes
ジョブ(Jobs)の実行 Monitoring　⇒　Jobs
その他 再パブリッシュすると、Processが最新バージョンを使うため、変更作業が必要 Processes　⇒　More Options　⇒　View Process　⇒　最新のバージョンに切り替える
ジョブの停止 停止(Stop)：必ずワークフロー内で「停止すべきか確認(Should Stop)」アクティビティを使用する 強制終了(Kill)：処理中の内容に関わらず、ジョブを停止する アクティブなジョブは削除できない パラメーター変更の優先順位 ジョブ (Jobs) -&amp;gt; プロセス (Processes) -&amp;gt; パッケージ(UiPath Studio)</description></item><item><title>uipath ノート（二）- Best Practice</title><link>https://www.takuzen.me/posts/2019-11-18-uipath-best-practice/</link><pubDate>Mon, 18 Nov 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-11-18-uipath-best-practice/</guid><description>時間をかけて各ワークフローに適したレイアウトを選択しましょう。 メイン: フローチャートまたはステートマシン
ビジネスロジック: フローチャート
UI インタラクション: シーケンス
フローチャートを使用することで、入れ子状の IF を回避
プロセスを小さなワークフローに分割しましょう。 分割したものを個別に開発、テスト
ワークフローの再利用
分割ファイルで作業することによる、より効率的な共同作業
必ず例外を処理しましょう。 例外が発生しやすいワークフローを [Try Catch (トライキャッチ)] ブロックに配置
外部から呼び出されたワークフローでも同様
リカバリシーケンスの設定
ワークフローを読みやすいものにしましょう。 すべてのコンポーネントにわかりやすい名前を選択
注記やコメントの使用
リアルタイムの実行状況のログ取得
環境設定を Config ファイルに格納
不要になったアプリケーションを終了させることで、常にクリーンな状態を維持しましょう。</description></item><item><title>JavaScript URI エンコーディング</title><link>https://www.takuzen.me/posts/2019-11-10-encodeuricomponent/</link><pubDate>Sun, 10 Nov 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-11-10-encodeuricomponent/</guid><description>まとめ encodeURI()とencodeURIComponent()はRFC 2396準拠である。 encodeURI() は完全な URI を表すのに必要な文字 (Reserved Characters) はエンコードしません。 また、予約されていないが &amp;ldquo;そのまま&amp;rdquo; URI に使用できる(Unreserved Marks) 文字をエンコードしません。 encodeURIComponent() は &amp;ldquo;Unreserved Marks&amp;rdquo; 文字をエンコードしません。
var set1 = &amp;#34;;,/?:@&amp;amp;=+$#&amp;#34;; // Reserved Characters var set2 = &amp;#34;-_.!~*&amp;#39;()&amp;#34;; // Unreserved Marks console.log(encodeURI(set1)); // ;,/?:@&amp;amp;=+$ console.log(encodeURI(set2)); // -_.!~*&amp;#39;() console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24 console.log(encodeURIComponent(set2)); // -_.!~*&amp;#39;() rfc2396 appendix-A https://tools.ietf.org/html/rfc2396#appendix-A
URI-reference = [ absoluteURI | relativeURI ] [ &amp;#34;#&amp;#34; fragment ] absoluteURI = scheme &amp;#34;:&amp;#34; ( hier_part | opaque_part ) relativeURI = ( net_path | abs_path | rel_path ) [ &amp;#34;?</description></item><item><title>uipath ノート（一）</title><link>https://www.takuzen.me/posts/2019-10-27-uipath/</link><pubDate>Sun, 27 Oct 2019 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2019-10-27-uipath/</guid><description>変数 Int32 String Boolean GenericValue　参照 UiPath Studio には GenericValue 変数の自動変換メカニズムがあり、式を正しく定義することで、目的の結果を得ることができます。式の最初の要素は、Studio から操作するガイドラインとして使用されることを考慮してください。例えば、2 つの GenericValue 変数を追加し、式の最初の変数が String として定義されてた場合、最初に代入された値を元に 2 つの値を結合し、文字列となります。 Integer として定義した場合の結果は、合計の値となります。
Array DataTime DataTable .Net 変数型を参照して探す方法
アクティビティ レイアウトダイアグラム シーエンス：　より高度で複雑な自動化に向こう フローチャート：　シンプルな自動化プロジェクトに適している ステートマシン Global Exception Handler (グローバル例外ハンドラー) 参照：https://docs.uipath.com/studio/lang-ja/docs/workflow-design
選択肢 条件分岐(If)：　シーケンス用条件分岐 フロー条件分岐(flow desicion)：　フローチャート用条件分岐 フロースイッチ (Flow Switch) 繰り返し 繰り返し（前判定）(While) 繰り返し（後判定）(Do While) 繰り返し（コレクションの各要素）(For Each) データ操作 CSVを読み込み(Read CSV) オプションにエンコーディングを指定できる（日本語データがある場合、&amp;quot;SHIFT-JIS&amp;quot;を指定する） 列名を含める(IncludeColumnNames)を指定できる 出力タイプ：System.Data.DataTable Microsoft Docs Selectメソッドで半角スペースを含む列名で指定する場合、半角スペースが特殊文字ではなく文字列として認識されるため、[]で列名を囲う Names.Select(&amp;#34;[メンバー ステータス] = &amp;#39;Yes&amp;#39;&amp;#34;) その他 メッセージボックス 代入(assign) 待機 (Delay) 入力ダイアログ（input dialog）: フォルダーを選択(Select Folder) 一行を書き込み(Write Line)：　Debug用？ アプリケーションを開く(Open Application) ブラウザを開く(Open Browser) ブラウザーにアタッチ(Attach Browser) 文字を入力(Type Into) ハイライト(Highlight) アンカーベース(Anchor Base) スクリーンショットをと撮る(Take Screenshot) 要素の有無を検出(Element Exists) 要素の消滅を待つ(Wait Element Vanish) レコーディング機能 [○]レコーディング可</description></item><item><title>Android中的MVP模式</title><link>https://www.takuzen.me/posts/2017-09-29-mvp-in-android/</link><pubDate>Fri, 29 Sep 2017 15:18:32 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-09-29-mvp-in-android/</guid><description>Model View Presenter (MVP) 模式是安卓开发中非常热门的一种架构模式。MVP模式将数据模型从传统的View层分离出来，通过presenter实现两者的间接通信。
(图片出处：vogella)
View层 该层专注于UI的实现，实现UI操作的接口，如showProgressBar, updateData等。通常会持有对Presenter层的引用，或通过依赖注入获取到Presenter实例。 Presenter层 该层实现业务逻辑，负责View层和Model层的控制和交互。该层通常应尽量避变对sdk产生依赖。 Model层 该层实现对数据操作的封装，暴露接口给Presenter层。</description></item><item><title>tcp拥塞控制算法总结（含BBR）</title><link>https://www.takuzen.me/posts/2017-05-02-tcp-congestion-control-algorithms/</link><pubDate>Tue, 02 May 2017 15:38:54 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-05-02-tcp-congestion-control-algorithms/</guid><description>Tahoe Tahoe是早期包含在 BCD 4.2 中的一个TCP早期版本。它在连接之初处于慢启动阶段。若遇到丢包事件，无论是超时还是快速重传，都会无条件将cwnd减为1个MSS，重新开始慢启动阶段，将ssthresh减为当前拥塞窗口的一半。对于有较大BDP（带宽延迟积）的链路来说，该方法会使得带宽利用率低下。
Vaegas Vegas算法试图在维持较好吞吐量的同时避免拥塞。它通过观察RTT来预测网络拥塞。当RTT增大时，Vegas认为网络正在发生拥塞，于是线性降低发送速率。利用RTT判断拥塞使得Vegas算法有较高的效率，但也导致采用Vegas的连接有较差的带宽竞争力。
Reno &amp;amp; NewReno Reno算法相当于是Tahoe算法的改进。它综合了快速恢复机制，当检测到快速重传时，Reno算法将cwnd减为当前窗口的一半加上3MSS，并将ssthresh设置为当前窗口的一半，然后cwnd进入线性增长。Reno算法存在的问题是它不能有效解决同一窗口丢失多个分组的情况（局部ACK），可能会严重影响网络吞吐性能。NewReno算法对这一问题进行了改进。它记录了上一个数据传输窗口的最高序列号（ACK恢复点），当结束到的ACK序列号不小于恢复点序列号时才会停止快速恢复阶段。NewReno是目前比较常用的一个TCP版本。
BIC-TCP BIC-TCP算法的主要目的在于，即使在拥塞窗口非常大的情况下也能满足线性RTT公平性。使用二分 搜索增大 和 加法增大 两种算法探测饱和点，通过 最大值探测 机制实现。Linux 2.6.8 至 2.6.17 内核版本中默认开启该算法。
CUBIC CUBIC算法改进了BIC-TCP算法中在某些情况下（低速网络）增长过快的不足，并对窗口增长机制进行了简化。它通过一个三次函数来控制窗口的增长。除此之外CUBIC还有 TCP友好 策略，确保在低速网络中CUBIC的友好性。从Linux 2.6.18 内核版本开始CUBIC成为了Linux默认的TCP拥塞控制算法。
BBR BBR是goole在2016年下半年公开的一种开源拥塞控制算法，已经包含在了Linux 4.9 内核版本中。采用丢包作为拥塞信号的代价就是，在有一定错误丢包率的链路上，标准拥塞控制算法通常会收敛到一个比较小的发送窗口上，并没有占满网络带宽。BBR不再关注丢包作为拥塞信号，而是通过交替测量带宽和延迟，用一段时间内的带宽极大值和延迟极小值作为估计值的乘积作为窗口估计值，因此BBR可以更充分的利用带宽。目前对BBR的评价有褒有贬，有人说时黑科技，有人说其抢占带宽不道德，有人说这是TCP发展的一大进步也是拥塞控制的未来发展方向，还有人说大范围部署BBR将是一场灾难。。。我对TCP/IP的学习还很皮毛，就不贸然站队了。不过我在境外vps上部署了BBR之后，跑在vps上的ss速度提升非常显著，个人来讲还是很喜欢的:).
相关链接 BBR: Congestion-Based Congestion Control https://www.zhihu.com/question/53559433 http://www.cqvip.com/read/read.aspx?id=23783845#</description></item><item><title>常用算法总结</title><link>https://www.takuzen.me/posts/2017-02-24-common-sorting-algorithms/</link><pubDate>Fri, 24 Feb 2017 19:47:40 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-02-24-common-sorting-algorithms/</guid><description>基于比较的排序算法的最优性能是O(n log n)
文中代码通用的两个方法：
private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &amp;lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable swap = a[i]; a[i] = a[j]; a[j] = swap; } 插入排序 Time Complexity: O(n ^ 2) 最好情况O(n) 稳定 in place public class Insertion { public static void sort(Comparable[] a) { int N = a.length; for (int i = 0; i &amp;lt; N; i++) for (int j = i; j &amp;gt; 0; j--) if (a[j] &amp;lt; a[j - 1]) { exch(a, j, j-1); } else break; } } 选择排序 Time Complexity: O(n ^ 2) 不稳定 in place public class Selection { public static void sort(Comparable[] a) { int N = a.</description></item><item><title>java散列知识点总结</title><link>https://www.takuzen.me/posts/2017-02-18-hash/</link><pubDate>Sat, 18 Feb 2017 19:19:01 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-02-18-hash/</guid><description>java 的根类 Object 具有 hashcode 方法。当 equal 方法被重写时也应当重写 hashcode 方法。
基本数据类型的散列码 byte short int char 类型的搜索键将会转换为 int。 float 类型的搜索键使用 Float.floatToIntBits(key) 作为散列码。 long 类型的搜索键会进行折叠操作，如下： iny hashCode = (int) (key ^ (key &amp;gt;&amp;gt; 32)); double 类型的搜索键会使用 Double.doubleToLongBits(key) 方法转换为 long 类型然后再进行折叠。 字符串类型的散列码 对于字符串一般使用多项式散列码进行计算，
这里放个公式的图
b的较好取值为31，33，37，39，41。在 java String 类中 b 取31。
public static int hash(String key, int tableSize) { int hashVal = 0; for (int i = 0; i &amp;lt; key.length(); i++) hashVal = 37*hashVal + key.</description></item><item><title>Algorithms part1 programming assignments 2 - deque</title><link>https://www.takuzen.me/posts/2017-02-10-algorithms-part1-assignments-2-deque/</link><pubDate>Fri, 10 Feb 2017 18:33:59 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-02-10-algorithms-part1-assignments-2-deque/</guid><description>这次作业内容是关于栈和队列的。要求为实现两种数据类型：deque 和 randomized queues。
Deque Deque: A double-ended queue or deque (pronounced &amp;ldquo;deck&amp;rdquo;) is a generalization of a stack and a queue that supports adding and removing items from either the front or the back of the data structure.
deque就是个双向队列，从两头都可以添加和删除。用链表实现起来比较方便。要求的api如下：
public class Deque&amp;lt;Item&amp;gt; implements Iterable&amp;lt;Item&amp;gt; { public Deque() // construct an empty deque public boolean isEmpty() // is the deque empty? public int size() // return the number of items on the deque public void addFirst(Item item) // add the item to the front public void addLast(Item item) // add the item to the end public Item removeFirst() // remove and return the item from the front public Item removeLast() // remove and return the item from the end public Iterator&amp;lt;Item&amp;gt; iterator() // return an iterator over items in order from front to end public static void main(String[] args) // unit testing (optional) } 题目要求每个deque的操作都必须是 O(1) 的时间复杂度，迭代器的操作也是 O(1) 的时间复杂度。包含n个元素的deque最多占用48n + 192 bytes。综合考虑采用双向链表比较合适。</description></item><item><title>Algorithms part1 programming assignments 1 - Percolation</title><link>https://www.takuzen.me/posts/2017-02-08-algorithms-part1-programming-assignments-1/</link><pubDate>Wed, 08 Feb 2017 20:48:32 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-02-08-algorithms-part1-programming-assignments-1/</guid><description>坚持看了很久的algorithms公开课，终于决定回过头来整理一下作业。。 这次作业解决的是渗滤系统的阈值问题。渗滤（percolation)是一个常见的物理系统，描述为：
We model a percolation system using an n-by-n grid of sites. Each site is either open or blocked. A full site is an open site that can be connected to an open site in the top row via a chain of neighboring (left, right, up, down) open sites. We say the system percolates if there is a full site in the bottom row. In other words, a system percolates if we fill all open sites connected to the top row and that process fills some open site on the bottom row.</description></item><item><title>php的闭包特性</title><link>https://www.takuzen.me/posts/2017-01-11-php-lambada/</link><pubDate>Wed, 11 Jan 2017 18:39:17 +0000</pubDate><guid>https://www.takuzen.me/posts/2017-01-11-php-lambada/</guid><description>闭包和匿名函数在PHP 5.3.0引入，并且PHP将两者视为相同的概念。闭包其实是伪装成函数的对象，它的实质其实是Closure实例。
创建闭包非常简单：
$c = function($name) { return sprintf(&amp;#34;Hello World! Hello %s!&amp;#34;, $name); }; echo $c(&amp;#39;PHP&amp;#39;); 使用use对闭包附加状态，多个参数使用,分隔：
function callPerson($name) { return function($about) use ($name) { return sprintf(&amp;#34;%s, %s&amp;#34;, $name, $about); } } $triver = callPerson(&amp;#39;Triver&amp;#39;); echo $triver(&amp;#34;slow down, please!!&amp;#34;); 附加的变量会被封装到闭包内，即使返回的闭包队形已经跳出了callPerson()的作用域也仍然会记住$name的值。
闭包有一个有趣的bindTo()方法，可以将闭包的内部状态绑定到其他对象上，第二个参数指定了绑定闭包的对象所属的类，从而实现在闭包中访问绑定对象的私有方法和属性。
class Bind { protected $name = &amp;#39;no name&amp;#39;; public $change; public function addAction($action) { $this-&amp;gt;change = $action-&amp;gt;bindTo($this, __CLASS__); } } $bind = new Bind(); $bind-&amp;gt;addAction(function() { $this-&amp;gt;name = &amp;#34;php&amp;#34;; return $this-&amp;gt;name; }); $change = $bind-&amp;gt;change; echo $change(); 使用这个特性可以方便的为类添加方法并绑定：</description></item><item><title>ruby学习笔记</title><link>https://www.takuzen.me/posts/2016-12-08-ruby-notes/</link><pubDate>Thu, 08 Dec 2016 22:54:49 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-12-08-ruby-notes/</guid><description>regular expressions =~是用于正则表达式的匹配操作符。返回匹配到的字符串位置或nil。
&amp;#34;abcdef&amp;#34; =~ /d/ # return 3 &amp;#34;aaaaaa&amp;#34; =~ /d/ # return nil !和? The exclamation point (!, sometimes pronounced aloud as &amp;ldquo;bang!&amp;rdquo;) indicates something potentially destructive, that is to say, something that can change the value of what it touches.
ruby&amp;gt; s1 = &amp;#34;forth&amp;#34; &amp;#34;forth&amp;#34; ruby&amp;gt; s1.chop! # This changes s1. &amp;#34;fort&amp;#34; ruby&amp;gt; s2 = s1.chop # This puts a changed copy in s2, &amp;#34;for&amp;#34; ruby&amp;gt; s1 # .</description></item><item><title>netfilter/iptables 笔记</title><link>https://www.takuzen.me/posts/2016-11-29-iptables-usage/</link><pubDate>Tue, 29 Nov 2016 21:08:52 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-11-29-iptables-usage/</guid><description>netfilter 与 iptables netfilter是linux默认的防火墙，在2.4之后的版本正式进入内核。netfilter 使用四个表(Table)来存放控制信息包过滤处理的规则集。每张表由链(Chain)组成，每条链又包含了多条规则(rule)。
iptables是用来编辑操作这些表的一个工具。iptables包中也包含了针对IPv6的工具ip6tables。
四个表及其包含的链：
filter INPUT FORWARD OUTPUT nat PREROUTING POSTROUTING OUTPUT mangle PREROUTING INPUT FORWARD OUTPUT POSTROUTING raw PREROUTING OUTPUT filter机制 filter是netfilter中最重要的机制，其任务是执行数据包的过滤操作。具有三种内建链：
INPUT - 来自外部的数据包（访问本机） OUTPUT - 发往外部的数据包（本机访问外部） FORWORD - “路过”本机的数据包，转发到其他设备 链中规则的匹配方式遵循first match。filter会根据数据包特征从相应链中的第一条规则开始逐一进行匹配。只要遇到满足特征的规则后便不再继续。 每条链在最底端都定义了默认规则。默认规则只会有一种状态：ACCEPT或者DROP。默认为ACCEPT。
iptables命令参数 格式：
iptables -操作方式 [链名] [条件匹配] [选项] iptables -[ACD] chain rule-specification [options] iptables -I chain [rulenum] rule-specification [options] iptables -R chain rulenum rule-specification [options] iptables -D chain rulenum [options] iptables -[LS] [chain [rulenum]] [options] iptables -[FZ] [chain] [options] iptables -[NX] chain iptables -E old-chain-name new-chain-name iptables -P chain target [options] iptables -h (print this help information) 常用操作方式：</description></item><item><title>laravel 5.2 事件广播</title><link>https://www.takuzen.me/posts/2016-10-08-laravel-event-broadcast/</link><pubDate>Sat, 08 Oct 2016 00:38:47 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-10-08-laravel-event-broadcast/</guid><description>简介 Laravel 事件提供了简单的观察者模式实现，允许你订阅和监听应用中的事件。事件类通常存放在 app/Events 目录，监听器存放在 app/Listeners。
配置 所有的事件广播配置选项都存放在 config/broadcasting.php 配置文件中。Laravel 支持多种广播驱动：Pusher、Redis以及一个服务于本地开发和调试的Log日志驱动。每一个驱动都已经有一个配置示例。基本上所有配置信息全可以在.env中指定，不需要改动broadcasting.php配置文件，如：
#在.env中配置驱动 BROADCAST_DRIVER=redis 注册事件和监听器 Laravel 自带的 EventServiceProvider（在 app/Providers/EventServiceProvider.php 中） 为事件注册提供了方便之所。其中的 listen 属性包含了事件（键）和对应监听器（值）数组。如果应用需要，你可以添加多个事件到该数组。例如，让我们添加 SomeEvent 事件：
/** * 事件监听器映射 * * @var array */ protected $listen = [ &amp;#39;App\Events\SomeEvent&amp;#39; =&amp;gt; [ &amp;#39;App\Listeners\SomeEventListener&amp;#39;, ], ]; 接下来使用event:generate命令生成对应的事件和监听器：
php artisan event:generate 执行后将会创建app/Events/SomeEvent.php 和 app/Listener/SomeEventListener.php。
除了上面在 EventServiceProvider 中注册事件的方式，还可以使用 Event 门面或者 Illuminate\Contracts\Events\Dispatcher 契约的具体实现类作为事件分发器手动注册事件：
/** * Register any other events for your application. * * @param \Illuminate\Contracts\Events\Dispatcher $events * @return void */ public function boot(DispatcherContract $events) { parent::boot($events); $events-&amp;gt;listen(&amp;#39;event.</description></item><item><title>ioc要点简记</title><link>https://www.takuzen.me/posts/2016-08-24-ioc-notes/</link><pubDate>Wed, 24 Aug 2016 01:50:45 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-08-24-ioc-notes/</guid><description>文中资料出处： 浅谈IOC&amp;ndash;说清楚IOC是什么 浅谈 Laravel 设计模式 深度理解依赖注入
IOC的含义 IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。
面向对象设计及编程的基本思想简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。
在面向对象设计的软件系统中，它的底层都是由N个对象构成的，各个对象之间通过相互合作，最终实现系统地业务逻辑。 伴随着应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。
IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。 由图可以看出，系统增加了在中间位置的第三方。此时构成系统的各个部分并没有耦合关系，而是是借助这个第三方来互相粘合。这个第三方也就是IOC容器的作用。在容器的穿针引线下，系统的各个部分才能结合起来发挥作用。如果图中没有IOC容器这个第三方存在，系统的各个部件彼此毫无联系。也就是说，在实现与变更A的时候，完全不用考虑与其他部件之间的影响。 这也就是IOC（控制反转）这个名字的含义： 软件系统在没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。 软件系统在引入IOC容器之后，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
//主动依赖 function __construct() { $this-&amp;gt;user = new UserModel(); } //被动依赖 function __construct(UserModel $user) { $this-&amp;gt;user = $user; } IOC中最基本的技术就是 反射(Reflection) 编程。反射通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。很多框架中都是把“反射”做为最基本的技术手段。
IOC的优缺点 优点 flexibility changing the implementation class for a widely used interface is simpler (e.g. replace a mock web service by the production instance) changing the retrieval strategy for a given class is simpler (e.</description></item><item><title>laravel设计模式</title><link>https://www.takuzen.me/posts/2016-08-20-laravel-design-patterns/</link><pubDate>Sat, 20 Aug 2016 23:29:17 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-08-20-laravel-design-patterns/</guid><description>DI与IOC laravel中实现了DI依赖注入，如：
class UserController { private $user; function __construct(UserModel $user) { $this-&amp;gt;user = $user; } } $user = new UserController(new UserMonel()); UserController依赖UserModel，在实例化时，laravel会自动主注入UserModel实例。</description></item><item><title>composer用法</title><link>https://www.takuzen.me/posts/2016-07-10-composer-usages/</link><pubDate>Sun, 10 Jul 2016 12:21:46 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-07-10-composer-usages/</guid><description>composer.json 要开始在你的项目中使用 Composer，你只需要一个composer.json文件。该文件包含了项目的依赖和其它的一些元数据。
首先需要指定require key的值
{ &amp;#34;require&amp;#34;: { &amp;#34;monolog/monolog&amp;#34;: &amp;#34;1.0.*&amp;#34; } &amp;#34;require-dev&amp;#34;: { &amp;#34;phpunit/phpunit&amp;#34;: &amp;#34;4.8.*&amp;#34; } } require属性列出组件依赖的组件，require-dev属性列出的是开发时所需依赖，在生产环境下不会安装。
包名 包名应该包含供应商名和项目名
包版本 指定版本号 1.0.2，1.0.0-dev，1.0.0-alpha3 范围 &amp;gt;=1.0 &amp;gt;=1.0,&amp;lt;2.0 &amp;gt;=1.0,&amp;lt;1.1|&amp;gt;=1.2 ,的优先级高于| 通配符 1.0.* 赋值运算符 ~1.2 相当于&amp;gt;=1.2,&amp;lt;2.0 允许依赖不稳定包 @beta @dev 形如1.0.*@beta，或者dev-master#2eb0c0978d290a1c45346a1955188929cb4e5db7这种明确了版本号的也是支持的。
波浪号运算符的意义在于，防止大版本更新而产生的兼容性问题。
Dist dist 指向一个存档，该存档是对一个资源包的某个版本的数据进行的打包。通常是已经发行的稳定版本。
Source source 指向一个开发中的源。这通常是一个源代码仓库，例如git。当你想要对下载下来的资源包进行修改时，可以这样获取。
你可以使用其中任意一个，或者同时使用。这取决于其它的一些因素，比如user-supplied 选项和包的稳定性，前者将会被优先考虑。
repositories 默认情况下 composer 只使用 packagist 作为包的资源库。通过指定资源库，你可以从其他地方获取资源包。
Repositories 并不是递归调用的，只能在Root包的 composer.json 中定义。附属包中的 composer.json 将被忽略。
支持一下类型的资源库：
composer: 一个 composer 类型的资源库，是一个简单的网络服务器（HTTP、FTP、SSH）上的 packages.json 文件，它包含一个 composer.json 对象的列表，有额外的 dist 和/或 source 信息。这个 packages.</description></item><item><title>git日常使用心得</title><link>https://www.takuzen.me/posts/2016-07-05-git-notes/</link><pubDate>Tue, 05 Jul 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-07-05-git-notes/</guid><description>As with many great things in life, Git began with a bit of creative destruction and fiery controversy.
版本控制 版本控制系统(VCS)是一套方便开发团队管理项目的工具。它可以追踪代码的每一次改动，并保存到特殊的数据库中。开发者可以轻松的将项目回滚到历史上的某一个版本上去。
分布式(Distributed)版本控制 是什么概念呢。在DVCS中，没有严格意义上的中央server，每一台用户终端都可以充当中央仓库的角色。因为用户终端并不是checkout了项目的快照，而是镜像了整个仓库。用户终端的仓库也可以互相推送自己的更新。
GIT的玄学哲学 Snapshots, Not Differences Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。这种形式也为git超强的分支管理打下了基础。
Nearly Every Operation Is Local 本地仓库包含了完整的项目历史，所以不需要经常通过网络读取数据。
If you’re used to a CVCS where most operations have that network latency overhead, this aspect of Git will make you think that the gods of speed have blessed Git with unworldly powers.</description></item><item><title>kali2016下phpredis的使用</title><link>https://www.takuzen.me/posts/2016-05-17-phpredis/</link><pubDate>Tue, 17 May 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-05-17-phpredis/</guid><description>phpredis安装 安装phpredis非常的简单，github上文档写的很详细。 在源码根目录执行：
phpize ./configure [--enable-redis-igbinary] sudo make &amp;amp;&amp;amp; sudo make install 对于没有安装phpize的情况，可以apt-get安装dev包
sudo apt-get install php5-dev 如果用的是php7，记得要使用php7分支，或者终端下载：
git clone -b php7 https://github.com/phpredis/phpredis.git</description></item><item><title>简记oath2.0</title><link>https://www.takuzen.me/posts/2016-04-22-understanding-oauth2/</link><pubDate>Fri, 22 Apr 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-04-22-understanding-oauth2/</guid><description>简介 OAuth2就是第三方应用获取授权的一套开放网络标准。它在客户端和服务端提供了一层中间授权层，客户端提供登录信息给授权层，登录成功后会拿到一张自己的通行令牌（token），客户端凭借此令牌别可以得到相行的服务端访问权限。
授权流程 客户端向用户提示授权 用户同意授权，向客户端提供授权许可（grant） 客户端向认证服务器发送认证请求，请求中包含用户提供的授权许可 认证成功后认证服务器向客户端发放令牌（token） 客户端使用令牌向服务器端请求资源 资源服务器验证令牌有效，答复请求 授权许可方式 在用户向客户端提供授权许可这一环节，OAuth2定义了四种类型：授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）、客户端模式（client credentials）。
授权码（authorization code） 这种模式中，客户端将用户引导到授权服务器上，用户同意授权后授权服务器将会令用户重定向至客户端指定的回调地址，并带有授权码。客户端收到授权码后便会自行请求认证服务器，认证服务器核对无误即会返回给客户端访问令牌和更新令牌。整个流程中用户实际上只是跟认证服务器提交了认证，并未与客户端分享任何登录信息。
简化模式（implicit） （懒得简化了，先贴出来放在这=。=） The implicit grant is a simplified authorization code flow optimized for clients implemented in a browser using a scripting language such as JavaScript. In the implicit flow, instead of issuing the client an authorization code, the client is issued an access token directly (as the result of the resource owner authorization).</description></item><item><title>php几种设计模式</title><link>https://www.takuzen.me/posts/2016-04-18-php-design-pattern/</link><pubDate>Mon, 18 Apr 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-04-18-php-design-pattern/</guid><description>php设计模式 单例模式 多例模式 代理模式 代理模式实际上就是解决了在有些不适合继承的情况下使用方法的问题。在proxy类中实现__call()方法调用被代理类的方法。
外观模式（facade） 装饰者模式(decorator) 工厂模式 观察者模式 发布者/订阅者模式</description></item><item><title>docker基础简记</title><link>https://www.takuzen.me/posts/2016-03-09-docker-guide/</link><pubDate>Wed, 09 Mar 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-03-09-docker-guide/</guid><description>Docker是什么 Docker allows you to package an application with all of its dependencies into a standardized unit for software development. &amp;mdash;-What is Docker?
Docker是近几年兴起的发展非常快速的开源项目，可用来创建非常轻量的“虚拟机”。在这里重要的两个概念是 镜像 和 容器 。
docker命令简记 run 启动 -t 在容器内指定一个终端 -i 允许对容器内的STDIN进行交互 -d 在容器内已后台进程模式运行 -P 将容器内部使用的网络端口随机映射到主机高端口上 -p 指定要绑定的端口，具体用法见文档 -e KEY=value 设置环境变量 &amp;ndash;name container_name 为容器命名 &amp;ndash;rm 创建临时容器，停止后删除 ps 查看正在运行的容器 -l 显示最后启动容器的详细信息 -a 显示所有容器，包括已经停止的 logs container_name 查看容器内的标准输出 -f 保持活动状态，动态显示新添加的信息 stop 停止正在工作的容器 version 返回Docker 客户端和进程的版本信息 port container_name top 查看容器内部运行的进程 inspect 查看容器的底层信息（配置和状态），JSON格式 -f &amp;lsquo;{{ obj.</description></item><item><title>基本的bash shell命令</title><link>https://www.takuzen.me/posts/2016-03-05-bash-shell/</link><pubDate>Sat, 05 Mar 2016 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2016-03-05-bash-shell/</guid><description>基本的bash shell命令 处理文件和目录 ls 输出目录 -s 显示文件大小 -a 输出隐藏文件 -i 显示文件的索引值 -l 产生长列表的输出 -R 递归列出子目录内容 touch 创建新文件或者改变访问/修改时间 -a 只改变访问时间 -m 只改变修改时间 -t 指定时间戳 cp 复制文件 -f 强制覆盖不提示 -i 覆盖前提示 -r 递归的复制文件 -R 递归的复制目录 -l 创建文件链接（硬链接） -s 创建符号链接（软连接） -v 详细模式 mv 移动文件（重命名） rm 删除文件 -i 删除前提示 -f 强制删除不提示 -r 递归删除非空目录 mkdir 创建目录 stat 提供文件的所有状态信息 file 查看文件类型 cat 显示文本数据 -n 给所有行加上行号 -b 给有文本的行加上行号 -s 多个空白行压缩为一行 -T 用^I替换制表符 more 分页显示 空格 显示下一屏 ENTER 显示下一行 /expression 查找 n 查找下一处匹配的内容 &amp;rsquo; 调到匹配的第一处内容 !</description></item><item><title>Kali的一些工具</title><link>https://www.takuzen.me/posts/2015-12-19-tools-of-kali/</link><pubDate>Sat, 19 Dec 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-12-19-tools-of-kali/</guid><description>信息收集 DNS信息 host 查询/etc/resolv.conf中指定的DNS服务器 dig 可处理文件内的所有DNS指令 dnsenum 可通过google搜素子域名；课使用字典对子域名进行暴力破解； dnsdict6 IPv6子域名枚举 fierce 能对不连续的IP空间和主机名进行测试 DMitry 具有DNS分析和路由分析功能，可进行简单端口探测 Maltego 图形化综合工具 路由信息 tcptraceroute 利用TCP SYN数据包进行路由信息探测 tctrace -i -h 搜索引擎 theharvester 通过多个公共资源搜集所需信息（Email、用户名、主机名等） Metagoofil 通过google搜索目标域的文件的元数据信息，kali2默认貌似没有安装 目标识别 识别主机 ping 老朋友。。 ping6 用来ping IPv6 fping 可同时探测多个主机或者整个网段 arping 使用ARP请求检测局域网内主机是否在线，IP或者MAC地址都可作为目标 hping3 端口扫描、防火墙规则检测、IDS检测等，功能强大 nping 支持多种协议探测模式；可做压力测试、ARP中毒、Dos攻击 nbtscan 审计局域网内windows系统IP地址、NetBIOS信息等 识别操作系统 p0f 被动方式探测目标主机 nmap 神器之一 服务枚举 端口扫描 nmap 端口扫描；主机探测；服务/版本检测；操作系统检测；网络路由跟踪；脚本引擎 -sT TCP连接扫描 -sS SYN扫描（半开连接扫描） -sN NULL扫描（不设置任何控制位） -sF FIN扫描 -sM TCP Maimom扫描，常用于探测BSD衍生出来的操作系统 -sA TCP ACK扫描，能检测防火墙，确定定被屏蔽端口 -sW TCP窗口扫描 -sI 通过僵尸主机发动扫描 &amp;ndash;scanflags 自定义URG、ACK、PSH、RST、SYN、FIN、ECE、CWR、ALL和NONE组合 -sU UDP扫描 -sV 服务版识别 -O 识别操作系统 -p 指定端口或端口范围 -F 快速扫描，近扫描常用100个端口 -r 顺序扫描 -oN 正常输出 -oX 将结果生成为XML文件 -A 强力扫描，相当于 -sV -O -sC &amp;ndash;traceroute -sC 使用默认类的脚本进行扫描 相当于&amp;ndash;script=default &amp;ndash;script 根据指定文件名、类别名、目录名执行相应脚本 -f 使用小数据包，避免目标IDS识别 &amp;ndash;mtu 调整数据包大小，必须是8的倍数 -D 在侦测数据包中掺杂一些假源IP的数据包。 -g 模拟源端口 &amp;ndash;data-length 改变数据包默认长度 &amp;ndash;scan-delay 控制发送探测数据的时间间隔 Unicornscna 扫描UDP端口性能卓越 zenmap nmap的图形化扫描工具 amap 检测指定端口上运行的应用程序信息 SNMP枚举 SNMP 简单网络管理协议，运行于161端口的应用层协议，用于网络设备运行状态的监控， SNMP协议有三个版本v1/v2/v3</description></item><item><title>Kali下Metasploit学习笔记</title><link>https://www.takuzen.me/posts/2015-12-07-metasploit-on-kali/</link><pubDate>Mon, 07 Dec 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-12-07-metasploit-on-kali/</guid><description>启动 使用框架前先开启其几个服务：
# service postgresql start # msfdb init 注意kali2.0开始不再有metasploit服务，所以官方文档说要用msfdb init代替service metasploit start
然后启动msf控制台
# msfconsole 一些命令 workspace -h 帮助 workspace [-a/d/r] 创建/删除/重命名工作平台</description></item><item><title>vi/vim命令简记</title><link>https://www.takuzen.me/posts/2015-12-05-vim-guide/</link><pubDate>Sat, 05 Dec 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-12-05-vim-guide/</guid><description>模式 vi有三种模式
命令模式 插入模式 扩展模式 命令模式下的操作 移动光标 h,j,k,l 左下上右 w/d 上一个字符/下一个字符 (/) 上一个句子/下一个句子 {/} 上一个段落/下一个段落 修改 cc/cw/cl 重写行/词/字符 dd/dw/dl 删除行/词/字符 yy/yw/yl 复制行/词/字符 dtc，删除从光标到c之间的所有字符 rc，将光标下的字符替换为c 5dd，删除5行数据 5yy，复制5行数据 5x，删除5个字符 p/P 粘贴复制修改或者删除的数据，p粘贴在行上，P粘贴在行下 撤销和恢复 u 撤销最近一次修改 ctrl+r 撤销最近一次撤销 U 撤销所有修改 搜索 /text 向后搜索 ?text 向前搜索 n 搜索下一个同样的的内容 N 搜索上一个同样内容 R，进入替换状态，esc退出 读取，保存与退出 读取保存退出这些操作都是在扩展模式下操作。
:w 保存 :w! 强制保存 :q 退出 :q! 强制退出 :wq 保存退出 :wq! 强制保存退出 :r filename 将另一个文件读入到当前文件内光标所在位置后 :1,20 w filename 将1-20行写入新文件中 :29,$ w filename 将第20行至最后一行写入新文件 :1,20 w&amp;raquo;filename 将第1值20行追加到另一个文件中 定位 G 跳转到文件最后一行 1G 跳转到文件的第一行 ctrl-d 往下滚动半屏 ctrl+u 往上滚动半屏 H 跳转到本屏显示的第一行 M 调转到本屏显示的中间一行 L 跳转到本屏显示的最后一行 z+Enter 使当前的行成为屏幕显示的第一行 z- 使当前行成为屏幕的最后一行 查找与替换 使用sed进行查找和替换 sed是linux下一个很常用的工具。在扩展模式下输入s即可使用sed进行替换。</description></item><item><title>C#学习笔记</title><link>https://www.takuzen.me/posts/2015-10-31-c-sharp-notes/</link><pubDate>Sat, 31 Oct 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-10-31-c-sharp-notes/</guid><description>这里记录的都是与c/c++不太一样的地方，
数据类型 值类型 从类System.ValueType中派生，比较独特的有decimal``sbyte; C#提供了内置类型转换的方法，例如ToBoolean``ToInt32``ToString等等。
可空类型(Nullable) 这个单独列出来了因为很有趣，他是允许值为正常类型范围内或者是null。
//语法 &amp;lt;date_type&amp;gt; ? &amp;lt;variable_name&amp;gt; = null; int? num1 = null; int? num2 = 250; Null合并运算符??用于定义可空类型和引用类型的默认值；如果第一个操作数的侍卫null则返回第二个操作数，否则返回第一个操作数的值。
//继续使用上面的num1和num2 int num3; num3 = num1 ?? 10;//num3 = 10; num3 = num2 ?? 38;//num3 = 250; 引用类型 引用类型不包含储存在变量中的实际数据。内置的引用类型有object``dynamic``string
对象(object)类型 object类型是c#通用类型系统CTS中所有数据的终极基类，可以分配任何类型的值。一个值类型转换为对象类型时称为__装箱__，反过来称为__拆箱__;
object obj； obj = 100;//装箱 动态(Dynamic)类型 类型检查在运行时发生。
dynamic a = 20; 字符串(String)类型 String是System.String类的别名，从对象类派生。有一个@分配方式（称作逐字字符串）。
String str1 = &amp;quot;Hello world&amp;quot;; String str2 = @&amp;quot;C:\Windows&amp;quot;;//转义字符会当作普通字符看待 @字符串中所有的换行符缩进符等都计算在字符串长度内。
指针类型 与c/c/c++有相同的类型；
type* identifier; 参数传递 C#中有三种参数传递方式：值参数、引用参数、输出参数。</description></item><item><title>jQury基础笔记</title><link>https://www.takuzen.me/posts/2015-10-01-jqury-notes/</link><pubDate>Thu, 01 Oct 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-10-01-jqury-notes/</guid><description>安装 1.从jqury.com下载
2.CDN
Baidu CDN:http://libs.baidu.com/jquery/1.10.2/jquery.min.js 又拍云 CDN:http://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js 新浪 CDN:http://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js Google CDN:http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js Microsoft CDN:http://ajax.htmlnetcdn.com/ajax/jQuery/jquery-1.10.2.min.js 语法 基础语法： $(selector).action()
选择器 jquery选择器基于已存在的css选择器
$(this) - 当前元素 $(&amp;quot;p&amp;quot;) - 所有 &amp;lt;p&amp;gt; 元素 $(&amp;quot;p:first&amp;quot;) - 选取第一个&amp;lt;p&amp;gt;元素 $(&amp;quot;p .test&amp;quot;) - 所有 class=&amp;ldquo;test&amp;rdquo; 的 &amp;lt;p&amp;gt; 元素 $(&amp;quot;.test&amp;quot;) - 所有class=&amp;ldquo;test&amp;quot;的元素 $(&amp;quot;#test&amp;quot;) - 所有 id=&amp;ldquo;test&amp;rdquo; 的元素 $(&amp;quot;[href]&amp;quot;) - 带有href属性的元素 $(&amp;quot;ui li:first&amp;quot;) - 选取第一个&amp;lt;ul&amp;gt;的第一个&amp;lt;li&amp;gt;元素 $(&amp;quot;ui li:first-child&amp;quot;) - 选取每个&amp;lt;ul&amp;gt;的第一个&amp;lt;li&amp;gt;元素 $(&amp;quot;a[target!='_blank']&amp;quot;) - 选取所有target属性值不等于&amp;rdquo;_blank&amp;quot;的&amp;lt;a&amp;gt;元素 $(&amp;quot;:button&amp;quot;) - 选取所有type=&amp;ldquo;button&amp;quot;的&amp;lt;input&amp;gt;元素和&amp;lt;button&amp;gt;元素
还有一些自定义的选择器
$(&amp;quot;tr:even&amp;quot;) - 选取奇数位置的&amp;lt;tr&amp;gt;，偶数为:odd $(&amp;quot;tr:nth-child(odd)&amp;quot;) - 相对于元素的父元素而非当前所选择的元素来选取偶数位置 $(&amp;quot;td:contains(monkey)&amp;quot;) - 选择含有&amp;rsquo;monkey&amp;rsquo;的表格单元</description></item><item><title>正则表达式笔记</title><link>https://www.takuzen.me/posts/2015-09-30-regular-expression-notes/</link><pubDate>Wed, 30 Sep 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-09-30-regular-expression-notes/</guid><description>元字符 . 匹配任何单个字符 * 匹配任意长度 + 匹配前面的一个或多个实例 ? 匹配前面的0个或多个实例 [...] 匹配方括号内的任意字符 ^ 匹配字符串开头 $ 匹配字符串末尾 {n,m} 匹配前面的字符出现n到m次 {n,} 匹配前面的字符至少出现三次 修饰符 修饰符位于结束定界符之后，用来改变正则表达式的行为。
i 不区分大小写 /s 忽略转义回车 /U 匹配字符域 [char list] 匹配方括号内的任意字符集，包括空格。此例即匹配c、h、a、r、空格、l、i、s、t中的任一字符 [^char list] 不匹配方括号内的字符，也可用! [a-z] 匹配字符a-z, 还有几个&amp;ndash;忘了叫啥了的&amp;ndash;
\w 相当与[A-Za-z0-9] \s 匹配空白字符，相当与[\t\r\n] \d 匹配数字，[0-9] \b backspace (0x08) (only if in a range specification) 注：大写效果与小写相反 实例1：
//下面两种效果相同 //匹配由字母数字下划线连字符组成，长度在3-15的用户名 //注意连字符需要转义 /^[\w_\-]{3,15}$/ /^[A-Za-z0-9_\-]{3,15}$/ 实例2：
//匹配email地址 //本地部分包含A-Za-z0-9等，不包含括号，#@;等 /^([\w!#@$&amp;amp;&amp;#39;*+\/=?^&amp;#39;{|}~.\-]+)@([\w]+\.)</description></item><item><title>markdown语法简记</title><link>https://www.takuzen.me/posts/2015-08-03-markdown-notes/</link><pubDate>Mon, 03 Aug 2015 09:00:00 +0000</pubDate><guid>https://www.takuzen.me/posts/2015-08-03-markdown-notes/</guid><description>0. 反斜杠 反斜杠可以将在markdown中有特殊意义的字符作为正常字符插入。
1. 标题 类Setext形式 =和-的数量随意，效果效果是相同的。
This is H1 ========== This is H2 ---------- 类atx形式 也可以写成前后对称的形式。
# H1 ## H2 ###### H6 注意在#与标题间必须存在至少一个空格或制表符
2. 引用 &amp;gt;在段落前加&amp;gt;进行引用。 在段落前加&amp;gt;进行引用。 在段落前加&amp;gt;进行引用。
&amp;gt;或者每行前加&amp;gt;进行引用。 &amp;gt;或者每行前加&amp;gt;进行引用。 &amp;gt;或者每行前加&amp;gt;进行引用。
效果相同。
在段落或者每句前加&amp;gt;进行引用 在段落或者每行前加&amp;gt;进行引用。 在段落或者每行前加&amp;gt;进行引用。
加上不同数量的&amp;gt;实现嵌套引用。
3. 代码区块 代码区块只需一个制表符或者4个空格：
当你想插入代码区块
只需4个空格或者1个制表符 标记一小段代码可以用反引号`包起来，在本文随处可见效果。
也可用```的形式：
``` 代码区块 ``` 将产生相同效果。但是此种方法并非标准markdown语法，有时可能会解析不正确。 在代码区块中可以方便的插入HTML原始码，Markdown会自动将&amp;lt;``&amp;amp;等转换为HTML实体。
4. 列表 无序列表
* red + green - yellow 三种形式等同。
red green yellow 有序列表
1. 吃 2. 粑粑 吃 粑粑 句点后要有空格。数字是多少都无所谓，产生的效果相同。</description></item></channel></rss>